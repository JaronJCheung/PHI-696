# Born Free But Everywhere in SHACL #

For this project, the class will divide into two teams. Teams will be divided according to the following tasks: 
```
1. Construct and validate a SHACL scheme for Basic Formal Ontology
2. Construct five useful, general, novel SHACL patterns
```
I strongly encourage you leverage your understanding of description logics for both tasks; if you understand what can be expressed in OWL, then you can more easily construct SHACL constraints on expressions in OWL. 
Protege allows one to construct and test SHACL constraints. If you explore a bit, you'll be able to identify a way to visualize the constraints in a graph as you develop them as well. 


## Task 1 ##

The team pursuing task 1 will focus on constructing and validating a SHACL scheme for Basic Formal Ontology (BFO). It is not enough, however, to simply construct a SHACL file that parallels the BFO OWL file. That can be automated, as a matter of fact. Completing this task, rather, requires the construction of a SHACL file that parallels the BFO owl file but also constrains compatible knowledge graphs built on BFO to as much of the First-Order Logic representation of BFO, as possible. As you know, the FOL version of BFO expresses semantic content that cannot be expressed in BFO OWL version, since the latter uses a more restrictive language than the former. 

To validate your SHACL schema for BFO, you will need to generate a knowledge graph based on BFO with instance data added. You will then need to run your SHACL schema against this knowledge graph and generate a report absent errors or warnings. This must be done while respecting the semantics of the FOL version of BFO to the extent possible. 

This work will provide the foundation for a publication that illustrates how SHACL may be used to bridge the semantics of a data model whose implementations require expressivity restrictions. Completion of this task will thus make you eligible for co-authorship on the resulting publication. Students are encouraged, but not required, to continue building on this work as a final course project. 

You will need the following files: 

1. [BFO-FOL](https://github.com/BFO-ontology/BFO-2020/tree/master/21838-2/pdf)
2. [BFO-OWL](https://github.com/BFO-ontology/BFO-2020/blob/master/21838-2/owl/bfo-2020.owl)

You may find the following resources useful:

3. [SHACL W3C](https://www.w3.org/TR/shacl/)
4. [BFO 2.0 User Guide](https://ncorwiki.buffalo.edu/index.php/Basic_Formal_Ontology_2.0) - Link under "Background Information" 


## Task 2 ##

The team pursuing task 2 will focus on constructing 5-10 useful, general, novel SHACL constraints. 

By "useful", I mean a SHACL constraint that reflects a compelling use case. For example, in the DASH library one finds dash:AllObjects which represents the set of all objects in a data graph, and which is used in scenarios where a shape is expected to apply to any object, no matter the subject or predicate. This is a useful constraint for determining whether a graph contains no literals. 

By "general", I mean a SHACL constraint that is not restricted to a single ontology, upper-level or otherwise, but rather can be used by many ontologies with minimal adjustment, if any. 

By "novel" I mean a SHACL constraint does not currently exist. I encourage you to explore widely to determine whether your constraint exists; I will be. You should not, for example, duplicate any constraints from the SHACL W3C documentation or from the DASH library, though you are free to use such constraints as inspiration. 

This work will provide the foundation for a publication describing a new extension of the SHACL library designed for wide use in the ontology community. Completion of this task will thus make you eligible for co-authorship on the resulting publication. Students are encouraged, but not required, to continue building on this work as a final course project. 

You may find the following resources useful: 

1. [SHACL W3C](https://www.w3.org/TR/shacl/)
2. [DASH Library](https://datashapes.org/dash.html)


## Assignment to Teams ##

The class will be divided evenly. Students are expected to determine allotment, but teams must be comprised of the same number of members (with a +1/-1 deviation allowed). This is an exercise in project management. I encourage you to identify a strategy early for dividing sub-tasks, setting deadlines, and addressing blockers to progress.  

I suggest setting up 15 minute 'stand-up' meetings every other day, where team members are expected to join. zoom call or meet in person and (a) explain what progress they have made on their sub-task, (b) explain what they intend to achieve before the next stand-up, and (c) share any blockers that have to progress. This is an effective way to keep members focused on a team goal, as well as opportunities to overcome challenges. 

___

To see our cumulative work thus far, please go to this link: https://docs.google.com/document/d/1miP3WUXwh3rG3AoBgrDXQrfRwlesV-7XlMhrtjQG2sc/edit#heading=h.qaiiyhng5r46

```
**Objectives for Project 5 Task 1 Completion:**

1. Generate a knowledge graph based on BFO with instance data added that respect the semantics of the first order logic version of BFO.
2. Construct a SHACL schema/file that parallels the BFO owl file but also constrains compatible knowledge graphs built on BFO to as much of the First-Order Logic representation of BFO, as possible.
3. Validate the SHACL schema/file for BFO by running the SHACL file against the knowledge graph based on BFO and generate a report absent errors or warnings.
```

___


**Part 1–Objective 1 & 2:**

1. Generate a knowledge graph based on BFO with instance data added that respect the semantics of the first order logic version of BFO.

**BFO 2020 Knowledge Graph with Instance Data Added:** [BFO_2020_Knowledge Graph.ttl](https://github.com/JaronJCheung/PHI-696/blob/JaronJCheung-P-5/BFO_2020_Knowledge%20Graph.ttl)

2. Construct a SHACL schema/file that parallels the BFO owl file but also constrains compatible knowledge graphs built on BFO to as much of the First-Order Logic representation of BFO, as possible.

**Astrea SCHACL Schema File:** https://github.com/JaronJCheung/PHI-696/blob/JaronJCheung-P-5/BFO_SHACL_SCHEMA_3.0.ttl

```
Work Distribution:
Karl: Continuant Mereology 
Finn: Generic Dependence
Olivia: History
Jaron: Material Entity
Ali:  Occurrent Mereology
Matt: Order
Giacomo: Participation
Tim: Spatial Axioms
```

___

**BFO 2020 Continuant Mereology Axioms ( ): Karl Peihong Xie**

```
#Continuant part of and has continuant part are inverse relations [eld-1]
#∀t,a,b(continuantPartOf(a,b,t)↔hasContinuantPart(b,a,t))
#continuant (bfo:0000002), continuant part of at some time (bfo:0000176), has continuant part at some time (bfo:0000178)
 
ex:eld-1 a sh:NodeShape ;
    	sh:targetClass bfo:0000002 ;
    	sh:and (
    	sh:or ( [ sh:not    	[ sh:property [ sh:path bfo:0000176 ] ] ]
          	[ sh:property   [ sh:path [ sh:inversePath bfo:0000178 ] ;
                           	   sh:minCount 1 ] ] )
    	sh:or ( [ sh:not    	[ sh:property [ sh:path bfo:0000178 ] ] ]
          	[ sh:property   [ sh:path [ sh:inversePath bfo:0000176 ] ;
                              	sh:minCount 1 ] ] )
    	).
```

```
#Continuant part of is reflexive at a time [mcd-1]
#∀a,t(instanceOf(a,independentContinuant,t)→continuantPartOf(a,a,t))
# independent continuant (bfo:0000004), continuant part of at some time (bfo:0000176)
 
ex:mcd-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000004 ;
    sh:rule [
    	a sh:TripleRule ;
    	sh:subject :this ;
    	sh:predicate bfo:0000176 ;
    	sh:object :this ;
    	sh:condition [
        	a sh:TriplePattern ;
        	sh:subject :this ;
        	sh:predicate rdf:type ;
    	    sh:object bfo:0000004 ;
    	] ;
	] .
```

```
#Proper continuant part of and has proper continuant part are inverse relations [hpm-1]
#∀t,a,b(properContinuantPartOf(a,b,t)↔hasProperContinuantPart(b,a,t))
#continuant (bfo:0000002), proper continuant part of at some time (bfo:0000175), has proper continuant part at some time (bfo:0000174)
 
ex:hpm-1 a sh:NodeShape ;
    	sh:targetClass bfo:0000002 ;
    	sh:and (
    	sh:or ( [ sh:not    	[ sh:property [ sh:path bfo:0000174 ] ] ]
          	[ sh:property   [ sh:path [sh:inversePath bfo:0000175 ] ;
                              	sh:minCount 1 ] ] )
    	sh:or ( [ sh:not        [ sh:property [ sh:path bfo:0000175 ] ] ]
          	[ sh:property   [ sh:path [ sh:inversePath bfo:0000174 ] ;
                              	sh:minCount 1 ] ] )
    	).
```

```
#Exists at is dissective on first argument when it is a continuant [uns-1]
#∀p,q,r(existsAt(p,q)∧continuantPartOf(r,p,q)→existsAt(r,q))
#exists_at (bfo:0000108), continuant part of at some time (bfo:0000176)
 
ex:uns-1
a sh:NodeShape ;
sh:targetSubjectsOf bfo:0000176;
	sh:or (
      	[sh:not [
      	sh:targetObjectsOf bfo:0000176;
      	sh:property [
      	sh:path bfo:0000108 
      	] ] ]
      	[sh:property [
      	sh:path bfo:0000108 ] ] ).
```

```
#A fiat point has no parts other than itself [jgo-1]
#∀fp,t,p(instanceOf(fp,fiatPoint,t)∧continuantPartOf(p,fp,t)→p=fp)
#fiat point (bfo:0000147), continuant part of at some time (bfo:0000176)
 
ex:jgo-1
	a sh:NodeShape ;
sh:targetClass bfo:0000147 ;
sh:property [
sh:path [sh:inversePath bfo:0000176] ;
sh:or (
[sh:maxCount 0]
[sh:hasValue :this; sh:maxCount 1; sh:minCount 1 ] ) ] .
```

``` 
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#Continuant part of is dissective on third argument, a temporal region [mqp-1]
#∀p,q,r,s(continuantPartOf(p,q,r)∧temporalPartOf(s,r)→continuantPartOf(p,q,s))
# continuant part of at some time (bfo:0000176), temporal part of (bfo:0000139)
#John recommends reading a paper on Temporally Qualified Continuant Strategy (TQCS) (link: https://johnbeverley.com/blogic/2018/6/13/binary-relations-in-owl-generic-and-specific ). The basic idea of TQCS is to technically divide a continuant (John) into different temporally qualified continuants or TQCs (John-2000, John2000-2085, John-april2023 and so on). These TQCs look like temporal parts of John, but we aren't thereby ontologically committed to them. Rather, they are ad hoc computational artifacts. However, with these ad hoc artifacts, a three-placed relationship claim "x is part of y at t" can be treated as a binary-relation claim in OWL like "xt is part of y", where "xt" is a TQC of x at t.
#A possible TQCS-based translation: ∀p,q,r,s(continuantPartOf(pr,qr)∧phaseOf(r,pr)∧phaseOf(r,qr)∧temporalPartOf(s,r) → continuantPartOf(ps,qs)∧phaseOf(s,ps)∧phaseOf(s,qs))
```
 
``` 
#If a has continuant part b then if a is an instance of fiat point then b is an instance of fiat point [jqd-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,fiatPoint,t)→instanceOf(q,fiatPoint,t))
# has continuant part at some time (bfo:0000178), fiat point (bfo:0000147)
 
ex:jqd-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000147 ;
	sh:property [
    	sh:path bfo:0000178 ;
    	sh:class bfo:0000147 ] .
```

``` 	
#x is a proper continuant part of y if and only if x is a continuant part of y but y is not continuant part of x [sls-1]
#∀x,y,t(properContinuantPartOf(x,y,t)↔continuantPartOf(x,y,t)∧¬continuantPartOf(y,x,t))
#proper continuant part at some time (bfo:0000175), continuant part of at some time (bfo:0000176), continuant (bfo:0000002)
 
ex:sls-1
a sh:NodeShape ;
sh:targetClass bfo:0000002 ;
sh:rule [
a sh:SPARQLRule ;
sh:prefixes bfo: ;
sh:construct """
CONSTRUCT {
?x bfo:0000176 ?y .
FILTER NOT EXIST {
?y bfo:0000176 ?x . }
}
WHERE {
?x bfo:0000175 ?y.
}
""" ; ] ;
sh:rule [
a sh:SPARQLRule ;
sh:prefixes bfo: ;
sh:construct """
CONSTRUCT {
?x bfo:0000175 ?y .
}
WHERE {
?x bfo:0000176 ?y .
FILTER NOT EXIST {
?y bfo:0000176 ?x . }
}
""" ; ] .
```

```
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#Proper continuant part of is dissective on third argument, a temporal region [vjv-1]
#∀p,q,r,s(properContinuantPartOf(p,q,r)∧temporalPartOf(s,r)→properContinuantPartOf(p,q,s))
#proper continuant part at some time (bfo:0000175), temporal part of (bfo:0000139)
#TQCS???
```

``` 
#If a continuant part of b then if a is an instance of material entity then b is an instance of material entity [dok-1]
#∀p,q,t(continuantPartOf(p,q,t)∧instanceOf(p,materialEntity,t)→instanceOf(q,materialEntity,t))
#continuant part of at some time (bfo:0000176), material entity (bfo:0000040)
 
ex:dok-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000040 ;
	sh:property [
    	sh:path bfo:0000176 ;
    	sh:class bfo:0000040 ] .
 ```

```
#If a continuant part of b then if a is an instance of spatial region then b is an instance of spatial region, and vice versa [kbr-1]
#∀p,q,t(continuantPartOf(p,q,t)→(instanceOf(p,spatialRegion,t)↔instanceOf(q,spatialRegion,t)))
#continuant part of at some time (bfo:0000176), spatial region (bfo:0000006)
 
ex:kbr-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000006 ;
	sh:property [
        sh:path bfo:0000176 ;
    	sh:class bfo:0000006 ] ;
sh:property [
    sh:path [sh:inversePath bfo:0000176 ] ;
    sh:class bfo:0000006 ]
 ```

```
#If a has continuant part b then if a is an instance of fiat surface then b is an instance of continuant fiat boundary [ysp-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,fiatSurface,t)→instanceOf(q,continuantFiatBoundary,t))
# has continuant part at some time (bfo:0000178), fiat surface (bfo:0000146), continuant fiat boundary (bfo:0000140)
 
ex:ysp-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000146 ;
	sh:property [
    	sh:path bfo:0000178 ;
    	sh:class bfo:0000140 ] .
```
 
```
#If a has continuant part b then if a is an instance of three dimensional spatial region then b is an instance of spatial region [fzg-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,threeDimensionalSpatialRegion,t)→instanceOf(q,spatialRegion,t))
# has continuant part at some time (bfo:0000178), three dimensional spatial region (bfo:0000028), spatial region (bfo:0000006)
 
ex:fzg-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000028 ;
	sh:property [
    	sh:path bfo:0000178 ;
    	sh:class bfo:0000006 ] .
```

```
#If a has continuant part b then if a is an instance of continuant fiat boundary then b is an instance of continuant fiat boundary [ixo-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,continuantFiatBoundary,t)→instanceOf(q,continuantFiatBoundary,t))
#has continuant part at some time (bfo:0000178), continuant fiat boundary (bfo:0000140)
 
ex:fzg-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000140 ;
	sh:property [
    	sh:path bfo:0000178 ;
    	sh:class bfo:0000140 ] .
```

``` 
#If a continuant part of b then if a is an instance of site then b is an instance of site or material entity [izr-1]
#∀p,q,t(continuantPartOf(p,q,t)∧instanceOf(p,site,t)→instanceOf(q,site,t)∨instanceOf(q,materialEntity,t))
#continuant part of at some time (bfo:0000176), site (bfo:0000029), material entity (bfo:0000040)
 
ex:izr-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000029 ;
	sh:property [
    	sh:path bfo:0000176 ;
        sh:node [
          sh:property [
            sh:path rdf:type ;
        	sh:or (  
          	[sh:class bfo:0000029 ]
[sh:class bfo:0000040 ] ) ] ] ] .
```
 
```
#If a continuant part of b then if a is an instance of independent continuant then b is an instance of independent continuant, and vice versa [cez-1]
#∀p,q,t(continuantPartOf(p,q,t)→(instanceOf(p,independentContinuant,t)↔instanceOf(q,independentContinuant,t)))
#continuant part of at some time (bfo:0000176), independent continuant (bfo:0000004)
 
ex:cez-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000004 ;
	sh:property [
    	sh:path bfo:0000176 ;
    	sh:class bfo:0000004 ] ;
sh:property [
    sh:path [sh:inversePath bfo:0000176 ] ;
    sh:class bfo:0000004 ]
```

```
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#Continuant part of is transitive at a time [plp-1]
#∀a,b,c,t,t2(continuantPartOf(a,b,t)∧continuantPartOf(b,c,t2)∧temporalPartOf(t,t2)→continuantPartOf(a,c,t))
#If x is a continuant part of y at t1, and y is a continuant part of z at t2, and t1 is a temporal part of t2, then x is a continuant part of z at t1.
#continuant part of at some time (bfo:0000176), temporal part of (bfo:0000139)
#TQCS???
```

```
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#Continuant part of is time indexed and has domain: continuant and range: continuant [bdd-1]
#∀a,b,t(continuantPartOf(a,b,t)→instanceOf(a,continuant,t)∧instanceOf(b,continuant,t)∧instanceOf(t,temporalRegion,t))
#continuant (bfo:0000002), continuant part of at some time (bfo:0000176), temporal region (bfo:0000008)
#TQCS???
```
 
```
#If a has continuant part b then if a is an instance of fiat line then b is an instance of fiat line or fiat point [cwp-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,fiatLine,t)→instanceOf(q,fiatLine,t)∨instanceOf(q,fiatPoint,t))
# has continuant part at some time (bfo:0000178), fiat line (bfo:0000142), fiat point (bfo:0000147)
 
ex:cwp-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000142 ;
	sh:property [
    	sh:path bfo:0000178 ;
        sh:node [
          sh:property [
            sh:path rdf:type ;
        	sh:or (  
        	  [sh:class bfo:0000142 ]
[sh:class bfo:0000147 ] ) ] ] ] .
```

``` 
#If a has continuant part b then if a is an instance of site then b is an instance of site or continuant fiat boundary [mjj-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,site,t)→instanceOf(q,site,t)∨instanceOf(q,continuantFiatBoundary,t))
# has continuant part at some time (bfo:0000178), site (bfo:0000029), continuant fiat boundary (bfo:0000140)
 
ex:mjj-1
	a sh:NodeShape ;
    sh:targetClass bfo:0000029 ;
	sh:property [
    	sh:path bfo:0000178 ;
        sh:node [
          sh:property [
            sh:path rdf:type ;
        	sh:or (  
          	[sh:class bfo:0000029 ]
[sh:class bfo:0000140 ] ) ] ] ] .
```

```
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#Proper continuant part of is time indexed and has domain: continuant and range: continuant [kte-1]
#∀a,b,t(properContinuantPartOf(a,b,t)→instanceOf(a,continuant,t)∧instanceOf(b,continuant,t)∧instanceOf(t,temporalRegion,t))
#continuant (bfo:0000002), proper continuant part of at some time (bfo:0000175), temporal region (bfo:0000008)
#TQCS???
```
 
```
#If a has continuant part b then if a is an instance of zero dimensional spatial region then b is an instance of zero dimensional spatial region [bfv-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,zeroDimensionalSpatialRegion,t)→instanceOf(q,zeroDimensionalSpatialRegion,t))
# has continuant part at some time (bfo:0000178), zero dimensional spatial region (bfo:0000018)
 
ex:bfv-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000018 ;
	sh:property [
    	sh:path bfo:0000178 ;
    	sh:class bfo:0000018 ] .
```

``` 
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#Proper continuant part of is transitive at a time [xpg-1]
#∀a,b,c,t,t2(properContinuantPartOf(a,b,t)∧properContinuantPartOf(b,c,t2)∧temporalPartOf(t,t2)→properContinuantPartOf(a,c,t))
#proper continuant part of at some time (bfo:0000175), temporal part of (bfo:0000139)
#TQCS???
```
 
```
#If a has continuant part b then if a is an instance of material entity then b is an instance of site or continuant fiat boundary or material entity [mic-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,materialEntity,t)→instanceOf(q,site,t)∨instanceOf(q,continuantFiatBoundary,t)∨instanceOf(q,materialEntity,t))
# has continuant part at some time (bfo:0000178), material entity (bfo:0000040), site (bfo:0000029), continuant fiat boundary (bfo:0000140)
 
ex:mic-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000040 ;
	sh:property [
    	sh:path bfo:0000178 ;
    	sh:node [
      	sh:property [
        	sh:path rdf:type ;
        	sh:node [
        	sh:or (  
          	[a bfo:0000029 ]
          	[a bfo:0000140 ]
          	[a bfo:0000040 ]
           	) ] ] ] ].
```

```
#If a has continuant part b then if a is an instance of one dimensional spatial region then b is an instance of one dimensional spatial region or zero dimensional spatial region [wne-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,oneDimensionalSpatialRegion,t)→instanceOf(q,oneDimensionalSpatialRegion,t)∨instanceOf(q,zeroDimensionalSpatialRegion,t))
# has continuant part at some time (bfo:0000178), one dimensional spatial region (bfo:0000026), zero dimensional spatial region (bfo:0000018)
 
ex:wne-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000026 ;
	sh:property [
    	sh:path bfo:0000178 ;
        sh:node [
          sh:property [
            sh:path rdf:type ;
        	sh:or (  
          	[sh:class bfo:0000026 ]
[sh:class bfo:0000018 ]
) ] ] ] .
```

```
#If at all times that two object aggreates exist each is part of the other, then they are identical [glc-1]
#∀a,b((∃t(instanceOf(a,objectAggregate,t)∧continuantPartOf(a,b,t)∧continuantPartOf(b,a,t)))∧(∀t(continuantPartOf(a,b,t)↔continuantPartOf(b,a,t)))→a=b)
#object aggregate (bfo:0000027), continuant part of at some time (bfo:0000176)
 
ex:glc-1
a sh:NodeShape ;
sh:targetClass bfo:0000027 ;
sh:rule [
a sh:SPARQLRule ;
sh:prefixes bfo: ;
sh:construct """
CONSTRUCT {
?a owl:sameAs ?b .
}
WHERE {
  ?a bfo:0000176 ?b .
  ?b bfo:0000176 ?a .
}
""" ; ] .
```

```
#If a material entity has a proper part, then at least one of its proper parts is not an immaterial entity [adm-1]
#∀m,t(instanceOf(m,materialEntity,t)∧(∃mp(continuantPartOf(mp,m,t)∧mp̸=m))→∃mp(mp̸=m∧continuantPartOf(mp,m,t)∧¬instanceOf(mp,immaterialEntity,t)))
#material entity (bfo:0000040), immaterial entity (bfo:0000141), has proper continuant part at some time (bfo:0000174)
 
ex:adm-1 a sh:NodeShape ;
        sh:targetClass bfo:0000040 ;
    	sh:or ( [ sh:not    	[ sh:property [ sh:path bfo:0000174 ] ; sh:minCount 1 ] ]
          	[sh:not    	[ sh:property [ sh:path bfo:0000174 ]; sh:class bfo:0000141] ]
) .
```

```
#If a has continuant part b then if a is an instance of two dimensional spatial region then b is an instance of two dimensional spatial region or one dimensional spatial region or zero dimensional spatial region [hbn-1]
#∀p,q,t(hasContinuantPart(p,q,t)∧instanceOf(p,twoDimensionalSpatialRegion,t)→instanceOf(q,twoDimensionalSpatialRegion,t)∨instanceOf(q,oneDimensionalSpatialRegion,t)∨instanceOf(q,zeroDimensionalSpatialRegion,t))
# has continuant part at some time (bfo:0000178), two dimensional spatial region (bfo:0000009), one dimensional spatial region (bfo:0000026), zero dimensional spatial region (bfo:0000018)
 
ex:hbn-1
	a sh:NodeShape ;
	sh:targetClass bfo:0000009 ;
	sh:property [
    	sh:path bfo:0000178 ;
        sh:node [
          sh:property [
            sh:path rdf:type ;
        	sh:or (  
          	[sh:class bfo:0000009 ]
[sh:class bfo:0000026 ]
[sh:class bfo:0000018 ]
) ] ] ] .
```

```
#If at any time that two non object aggreates exist each is part of the other, then they are identical [tab-1]
#∀a,b(∃t(instanceOf(a,independentContinuant,t)∧¬instanceOf(a,objectAggregate,t)∧instanceOf(b,independentContinuant,t)∧¬instanceOf(b,objectAggregate,t)∧continuantPartOf(a,b,t)∧continuantPartOf(b,a,t))→a=b)
#independent continuant (bfo:0000004), object aggregate (bfo:0000027), continuant part of at some time (bfo:0000176), continuant part of at all time (bfo:0000177)
 
ex:tab-1
a sh:NodeShape ;
sh:targetClass bfo:0000004 ;
sh:rule [
a sh:SPARQLRule ;
sh:prefixes bfo: ;
sh:construct """
CONSTRUCT {
?a owl:sameAs ?b .
}
WHERE {
  ?a bfo:0000176 ?b .
  ?b bfo:0000176 ?a .
  FILTER NOT EXISTS {
	?a a bfo:0000027 .
?b a bfo:0000027 . }
}
""" ; ] .
```

``` 
#Continuant part of has weak supplementation [fyf-1]
#∀t,x,y(instanceOf(x,continuant,t)∧instanceOf(y,continuant,t)∧instanceOf(t,temporalRegion,t)→(continuantPartOf(x,y,t)∧x̸=y→∃z(instanceOf(z,continuant,t)∧continuantPartOf(z,y,t)∧z̸=y∧¬(∃overlap(instanceOf(overlap,continuant,t)∧continuantPartOf(overlap,x,t)∧continuantPartOf(overlap,z,t))))))
#Axiom [tab-1]: For any two continuants x and y, and any temporal region t, if x is a continuant part of y at t and x is not equal to y, then there exists a continuant z such that z is a continuant part of y at t and z is not equal to y, and x and z has no common continuant part at t.
#continuant (bfo:0000002), temporal region (bfo:0000008), continuant part of at some time (bfo:0000176)
 
ex:fyf-1
a sh:NodeShape ;
sh:targetClass bfo:0000002 ;
sh:rule [
a sh:SPARQLRule ;
sh:prefixes bfo: ;
sh:ask """
ASK WHERE {
  ?x bfo:0000176 ?y .
  ?z bfo:0000176 ?y .
  FILTER (?x != ?y && ?z != ?y)
  FILTER NOT EXISTS {
	?w bfo:0000176 ?x .
?w bfo:0000176 ?z . }
}
""" ; ] .
```

```
#Continuant part of has a unique product at a time [gzr-1]
#∀x,y,t(instanceOf(x,continuant,t)∧instanceOf(y,continuant,t)∧instanceOf(t,temporalRegion,t)→(∃overlap(instanceOf(overlap,continuant,t)∧continuantPartOf(overlap,x,t)∧continuantPartOf(overlap,y,t))→∃overlap(instanceOf(overlap,continuant,t)∧(∀w(instanceOf(w,continuant,t)→(continuantPartOf(w,overlap,t)↔continuantPartOf(w,x,t)∧continuantPartOf(w,y,t)))))))
#continuant (bfo:0000002), temporal region (bfo:0000008), continuant part of at some time (bfo:0000176)
#[gzr-1]: For any two continuants x and y, if x and y have a common continuant part, then there exists a product z such that w is a continuant part of z iff w is both a continuant part of x and a continuant part of y.
 
ex:gzr-1
a sh:NodeShape ;
sh:targetClass bfo:0000002 ;
sh:rule [
a sh:SPARQLRule ;
sh:prefixes bfo: ;
sh:construct """
CONSTRUCT {
?w bfo:0000176 ?z .
}
WHERE {
  ?w bfo:0000176 ?x .
  ?w bfo:0000176 ?y .
}
""" ; ] ;
sh:rule [
a sh:SPARQLRule ;
sh:prefixes bfo: ;
sh:construct """
CONSTRUCT {
?w bfo:0000176 ?x .
  ?w bfo:0000176 ?y .
}
WHERE {
  ?s bfo:0000176 ?x .
  ?s bfo:0000176 ?y .
  w? bfo:0000176 ?z .
}
""" ; ] .
```

___

**BFO 2020 Existence Instantiation Axioms (8 axioms, 2 not included in the final SHACL schema): Giacomo De Colle**

‘‘‘
#Particulars exist at some time [nmq-1]
#∀p(particular(p)→∃t existsAt(p,t))
#Bfo:entity (bfo:0000001) bfo:existsat (bfo:0000108)

ex:Particulars_exist_at_some_time_nmq-1
    a sh:NodeShape ;
    sh:targetClass obo:bfo_0000001 ;
    sh:property [       
    sh:path obo:bfo_0000108 ;     
    sh:minCount 1 ;    
    ] .
‘‘‘

‘‘‘
#Every universal is instantiated at least once [mbf-1]
#∀u(universal(u)→∃p,t instanceOf(p,u,t))

ex:Every_universal_is_instantiated
    a sh:NodeShape ;
    sh:targetObjectsOf rdf:type;
            sh:property [
            sh:path bfo:exists_at;
            sh:minCount 1 ;
        ]  .
‘‘‘

‘‘‘
#Exists at is dissective on first argument when it is a continuant [uns-1]
#∀p,q,r(existsAt(p,q)∧continuantPartOf(r,p,q)→existsAt(r,q))
# continuantpartofatsometime (BFO:0000176)
#bfo:existsat (bfo:0000108)

ex:uns-1
a sh:NodeShape ;
sh:targetSubjectsOf bfo:0000176;
    sh:or (
          [sh:not [
          sh:targetObjectsOf bfo:0000176;
          sh:property [
          sh:path bfo:0000108;
          sh:minCount 1
          ] ] ]
          [sh:property [
          sh:path bfo:0000108;
sh:minCount 1] ] ).
‘‘‘

‘‘‘
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#Instance of is dissective on third argument, a temporal region [qaf-1]
#∀p,q,r,s(instanceOf(p,q,r)∧temporalPartOf(s,r)→instanceOf(p,q,s))
#This “should” work, but again I get a pretty much uninformative “something went wrong”

#temporal part of (bfo:0000139) bfo:existsat (bfo:0000108) bfo:temporalregion (bfo:0000008)

ex:instance_dissective_temporal_region_qas-1
a sh:NodeShape ;
sh:targetClass bfo:entity;
    sh:or (
          [sh:not [
          sh:targetSubjectsOf rdf:type;
          sh:property [
          sh:path bfo:0000108;
          sh:minCount 1
            ];
          sh:and [sh:property [ sh:path [ sh:inversePath bfo:0000108 ];
sh:minCount 1 ];];
          sh:and [ sh:property [ sh:path bfo:0000139; sh:minCount 1];]
          ];]
          [sh:targetObjectsOf bfo:0000139; sh:property [ sh:path
          [ sh:inversePath bfo:0000108 ]; sh:minCount 1
      ]; ] ).
‘‘‘

‘‘‘
#Relata of exists at are particulars. [oap-1]
#∀p,q,r,s(instanceOf(p,q,r)∧temporalPartOf(s,r)→instanceOf(p,q,s))
#bfo:existsat (bfo:0000108) bfo:temporalregion (bfo:0000008)

ex:relata_of_existence_are_particulars_oap-1
a sh:NodeShape ;
sh:targetClass bfo:Entity ;
sh:or ([ sh:not [
sh:property [
sh:path bfo:0000108; ]] ]    
[ sh:property   [      
sh:path bfo:0000108;
sh:minCount 1; 
sh:hasValue bfo:0000008;
] ]  ) .
‘‘‘

‘‘‘
#Relata of instance of are particular, universal, temporal region. [lqn-1]
#∀i,u,t(instanceOf(i,u,t)→particular(i)∧universal(u)∧instanceOf(t,temporalRegion,t))

ex:instance_of_relata_lqn-1
a sh:NodeShape ;
sh:targetSubjectsOf rdf:type ;
sh:property [sh:path bfo:0000108;
 sh:minCount 1 ;    ].
‘‘‘

‘‘‘
#There is always something that exists [nis-1]
#∀t(instanceOf(t,temporalRegion,t)→∃u,i(i̸=t∧universal(u)∧particular(i)∧instanceOf(i,u,t)))

ex:something_exists_nis-1
a sh:NodeShape ;
sh:targetClass bfo:0000008 ;
sh:property [sh:path [sh:inversePath bfo:0000108]
 sh:minCount 1 ;    ].
‘‘‘

‘‘‘
#If m is a material entity, then there is some one dimensional temporal region during which m exists [zuw-1]
#∀m(∃tinstanceOf(m,materialEntity,t)→∃t(instanceOf(t,oneDimensionalTemporalRegion,t)∧existsAt(m,t)))

 ex:material_entities_exist_at_time_zuw-1
    a sh:NodeShape ;
    sh:targetClass bfo:0000040;
    sh:property [
    sh:path bfo:0000108; 
    sh:minCount 1;
        ].
‘‘‘

‘‘‘
*This axiom and SHACL shape has not been added to the final SHACL schema as it returns either an error or violation.

#If you exist you instatiate a universal and vice versa [bee-1]
#∀a,t(∃u(universal(u)∧instanceOf(a,u,t)∧instanceOf(t,temporalRegion,t))↔particular(a)∧instanceOf(t,temporalRegion,t)∧existsAt(a,t))
#I think this should work but the bfo shacl program tells me the quite uninformative “error”. So it’s not a syntax problem, otherwise it would have told me. 

ex:existence_instantiates_universals_bee-1
    a sh:NodeShape ;
        sh:targetClass bfo:0000001 ; 
        sh:or ([ sh:not [
sh:property [
sh:path bfo:0000108; ]]]    
[ sh:property   [      
sh:path rdf:type;
sh:minCount 1;
] ] );
sh:and [
sh:or ([ sh:not [
sh:property [
sh:path rdf:type; ]]]    
[ sh:property   [      
sh:path bfo:0000108;
sh:minCount 1; 
sh:hasValue bfo:0000008;
] ] )] .
‘‘‘

___

**BFO 2020 Generic Dependence Axioms**

Concretizes and is concretized by are inverse relations [zba-1]
∀t,a,b(concretizes(a,b,t)↔isConcretizedBy(b,a,t))

Generically depends on and is carrier of are inverse relations [mvp-1]
∀t,a,b(genericallyDependsOn(a,b,t)↔isCarrierOf(b,a,t))

Concretizes is dissective on third argument, a temporal region [nyz-1]
∀p,q,r,s(concretizes(p,q,r)∧temporalPartOf(s,r)→concretizes(p,q,s))

A generically dependent continuant is at all times at which it exists concretized by something [ibk-1]
∀t,g(instanceOf(g,genericallyDependentContinuant,t)→∃s,tp(temporalPartOf(tp,t)∧concretizes(s,g,tp)))

A g dependent continuant b g depends on an independent continuant c at t means: there inheres in c at t an s dependent continuant which concretizes b at t [otx-1]
∀g,c,t(genericallyDependsOn(g,c,t)→∃s,tp(temporalPartOf(tp,t)∧inheresIn(s,c)∧concretizes(s,g,tp)))

Concretizes is time indexed and has domain: specifically dependent continuant or process and range: generically dependent continuant [rog-1]
∀a,b,t(concretizes(a,b,t)→(instanceOf(a,specificallyDependentContinuant,t)∨instanceOf(a,process,t))∧instanceOf(b,genericallyDependentContinuant,t)∧instanceOf(t,temporalRegion,t))

Generically depends on is time indexed and has domain: generically dependent continuant and range: independent continuant but not spatial region [ekp-1]
∀a,b,t(genericallyDependsOn(a,b,t)→instanceOf(a,genericallyDependentContinuant,t)∧instanceOf(b,independentContinuant,t)∧¬instanceOf(b,spatialRegion,t)∧instanceOf(t,temporalRegion,t))

If a specifically dependent continuant concretizes a gdc then the gdc generically depends on the bearer of the sdc [cik-1]
∀g,b,sdc(∃tinstanceOf(g,genericallyDependentContinuant,t)∧∃tinstanceOf(sdc,specificallyDependentContinuant,t)∧∃tinstanceOf(b,independentContinuant,t)→∀t(concretizes(sdc,g,t)∧inheresIn(sdc,b)→genericallyDependsOn(g,b,t)))

If a generically dependent continuant participates in a process p then, if it is concretized as a process, that process is part of p, fand if concretized as an sdc then the bearer of that sdc participates in the process [fmm-1]
∀gdc,p,t(instanceOf(gdc,genericallyDependentContinuant,t)∧participatesIn(gdc,p,t)→∃tp,b(temporalPartOf(tp,t)∧concretizes(b,gdc,tp)∧((instanceOf(b,specificallyDependentContinuant,tp)∧(∃ic(specificallyDependsOn(b,ic)∧participatesIn(ic,p,tp))))∨(occurrentPartOf(b,p)∧existsAt(b,tp))))

___

**BFO 2020 History Axioms**

History of and has history are inverse relations [abx-1]
∀a,b(historyOf(a,b)↔hasHistory(b,a))

History of is functional on second argument [zek-1]
∀p,q,r(historyOf(p,q)∧historyOf(p,r)→q=r)

History of is functional on first argument [woe-1]
∀p,q,r(historyOf(p,q)∧historyOf(r,q)→p=r)

Every history is the history of something [vvy-1]
∀h(∃tinstanceOf(h,history,t)→∃m historyOf(h,m))

Every material entity has a history [okt-1]
∀m(∃tinstanceOf(m,materialEntity,t)→∃hhistoryOf(h,m))

A material entity participates in its history [lga-1]
∀h,m(historyOf(h,m)→∀t(existsAt(m,t)→participatesIn(m,h,t)))

Material entity and its history exist at exactly the same times [uzz-1]
∀m,h(historyOf(h,m)→∀t(instanceOf(m,materialEntity,t)↔instanceOf(h,history,t)))

History of has domain history and range material entity [rph-1]
∀a,b(historyOf(a,b)→∃tinstanceOf(a,history,t)∧∃t instanceOf(b,materialEntity,t)

___

**BFO 2020 Material Entity Axioms**

```
#Member part of and has member part are inverse relations [jrm-1]
#∀t,a,b(memberPartOf(a,b,t)↔hasMemberPart(b,a,t))
#Entity (bfo:0000001), Member part of at some time (bfo:0000129), has member part at some time (bfo:0000115)

ex:jrm-1 a sh:NodeShape ;
    sh:targetClass bfo:0000001 ;
    sh:property [        a sh:PropertyShape ;        sh:path bfo:0000129 ;        sh:inversePath bfo:0000115 ;        sh:class bfo:0000001 ;        sh:minCount 0 ;    ] ;
    sh:property [        a sh:PropertyShape ;        sh:path bfo:0000115 ;        sh:inversePath bfo:0000129;        sh:class bfo:0000001 ;        sh:minCount 0 ;    ] .
```

```
#Member part of is dissective on third argument, a temporal region [yip-1]
#∀p,q,r,s(memberPartOf(p,q,r)∧temporalPartOf(s,r)→memberPartOf(p,q,s))
#Entity (bfo:0000001), member part of at some time (bfo:0000129), temporal part of (bfo:0000139), temporal region (bfo:0000008)
 
ex:yip-1 a sh:NodeShape ;
    sh:targetObjectsOf bfo:0000001 ;
    sh:property [
        sh:path bfo:0000129 ;
        sh:nodeKind sh:IRI ;
        sh:qualifiedMinCount 3 ;
        sh:qualifiedMaxCount 3 ;
        sh:property [
            sh:path bfo:0000129 ;
            sh:nodeKind sh:IRI ;
            sh:in bfo:0000001 ;
        ] ;
        sh:property [
            sh:path bfo:0000129 ;
            sh:nodeKind sh:IRI ;
            sh:in bfo:0000008 ;
            sh:disjoint [
                sh:path bfo:0000139 ;
                sh:hasValue :yip-1 ;
            ]
        ]
    ] .
```

```
#An object aggregate always has at least one member [uhs-1]
#∀ag,t(instanceOf(ag,objectAggregate,t)→∃o1(instanceOf(o1,object,t)∧membePartOf(o1,ag,t)))
#Object aggregate (bfo:0000027), object (bfo:0000030), (Member part of at all times
(bfo:0000173).
 
ex:uhs-1
    a sh:NodeShape ;
    sh:targetObjectsOf bfo:0000027 ;
    sh:property [
        sh:path bfo:0000027 ;
        sh:nodeKind sh:IRI ;
        sh:minCount 1 ;
        sh:property [
            sh:path bfo:0000173 ;
            sh:nodeKind sh:IRI ;
            sh:in bfo:0000027 ;
        ] ;
        sh:property [
            sh:path bfo:0000030 ;
            sh:nodeKind sh:IRI ;
            sh:in bfo:0000027 ;
        ]
    ] .
```

```
#Member part of is time indexed and has domain: object and range: object aggregate [dvq-1]
#∀a,b,t(memberPartOf(a,b,t)→instanceOf(a,object,t)∧instanceOf(b,objectAggregate,t)∧instanceOf(t,temporalRegion,t))
#Entity (bfo:0000001), member part of at some time (bfo:0000129), object (bfo:0000030), objectAggregate (bfo:0000027), temporal region (bfo:0000008)
 
ex:dvq-1
    a sh:NodeShape ;
    sh:targetObjectsOf bfo:0000001 ;
    sh:property [
        sh:path bfo:0000129 ;
        sh:nodeKind sh:IRI ;
        sh:property [
            sh:path rdf:type ;
            sh:nodeKind sh:IRI ;
            sh:in bfo:0000030 ;
        ] ;
        sh:property [
            sh:path rdf:type ;
            sh:nodeKind sh:IRI ;
            sh:in bfo:0000027 ;
        ] ;
        sh:property [
            sh:path rdf:type ;
            sh:nodeKind sh:IRI ;
            sh:in bfo:0000008 ;
        ]
    ] .
```

```
#A fiat object part =def a proper part of an object [yir-1]
#∀f,t(instanceOf(f,fiatObjectPart,t)↔∃o(instanceOf(o,object,t)∧properContinuantPartOf(f,o,t)∧¬instanceOf(f,immaterialEntity,t)))
#Fiat object property (bfo:0000024), object (bfo:0000030), proper continuant part of at some time (bfo:0000175), immaterial entity (bfo:0000141)

ex:yir-1
  a sh:NodeShape ;
  sh:targetClass bfo:0000024 ;
  sh:property [
    sh:path bfo:0000030 ;
    sh:nodeKind sh:IRI ;
    sh:property [
      sh:path bfo:0000175 ;
      sh:nodeKind sh:IRI ;
      sh:hasValue bfo:0000024 ;
    ] ;
    sh:property [
      sh:path rdf:type ;
      sh:in (bfo:0000030) ;
    ] ;
    sh:property [
      sh:path bfo:0000175 ;
      sh:nodeKind sh:IRI ;
      sh:maxCount 1 ;
    ] ;
    sh:property [
      sh:path bfo:0000175 ;
      sh:nodeKind sh:IRI ;
      sh:not [        sh:path rdf:type ;        sh:in (bfo:0000141) ;      ] ;
    ] ;
  ] .
```

```
#I is an immaterial entity = Def. i is an independent continuant that has no material entities as parts. [udu-1]
#∀i,t(instanceOf(i,immaterialEntity,t)↔instanceOf(i,independentContinuant,t)∧¬(∃m(instanceOf(m,materialEntity,t)∧continuantPartOf(m,i,t))))
#Immaterial entity (bfo:0000141), independent continuant (bfo:0000004), material entity (bfo:0000040), continuant part of at all times (bfo:0000177).
 
ex:udu-1
  a sh:NodeShape ;
  sh:targetSubjectsOf bfo:0000141 ;
  sh:property [
    sh:path rdf:type ;
    sh:in (bfo:0000141) ;
  ] ;
  sh:property [
    sh:path rdf:type ;
    sh:in (bfo:0000004) ;
  ] ;
  sh:property [
    sh:path bfo:0000177 ;
    sh:nodeKind sh:BlankNodeOrIRI ;
    sh:minCount 0 ;
    sh:maxCount 1 ;
    sh:or (
      [
        sh:path rdf:type ;
        sh:in (bfo:0000040) ;
      ] 
      [        sh:path bfo:0000177 ;        sh:nodeKind sh:BlankNodeOrIRI ;        sh:maxCount 0 ;      ]
    )
  ] .
```

```
#Any continuant that doesn’t s depend or g depend on something is an independant continuant [ilw-1]
#∀c1(∃tinstanceOf(c1,independentContinuant,t)↔∃tinstanceOf(c1,continuant,t)∧¬(∃c2,t(specificallyDependsOn(c1,c2)∨genericallyDependsOn(c1,c2,t))))
	#Independent continuant (bfo:0000004), continuant (bfo:0000002), specifically depends on (bfo:0000195), generically depends on at some time (bfo:0000084)

ex:ilw-1
    a sh:NodeShape ;
    sh:targetSubjectsOf bfo:0000002 ;
    sh:property [
        sh:path bfo:0000195 ;
        sh:severity sh:Violation ;
        sh:message "Continuant should not have specific dependency relation"
    ] ;
    sh:property [
        sh:path bfo:0000084 ;
        sh:severity sh:Violation ;
        sh:message "Continuant should not have generic dependency relation"
    ] ;
    sh:property [
        sh:path (rdf:type) ;
        sh:hasValue bfo:0000004 ;
        sh:severity sh:Violation ;
        sh:message "Continuant should be an instance of IndependentContinuant"
    ] .
```

```
#An object aggregate has more than one member at at least one time [ibd-1]
#∀ag(∃tinstanceOf(ag,objectAggregate,t)→∃o1,o2,t(o1̸=o2∧instanceOf(o1,object,t)∧memberPartOf(o1,ag,t)∧instanceOf(o2,object,t)∧memberPartOf(o2,ag,t)))
#ObjectAggregate (bfo:0000027), object (bfo:0000030), member part of at some time (bfo:0000129)

ex:ibd-1
    a sh:NodeShape ;
    sh:targetObjectsOf bfo:0000027 ;
    sh:property [
        sh:path bfo:0000129 ;
        sh:minCount 2 ;
        sh:class bfo:0000030 ;
        sh:severity sh:Violation ;
        sh:message "ObjectAggregate should have at least 2 distinct members"
    ] .
```

```
#All parts of an aggregate overlap some member [fsy-1]
#∀t,b,x(properContinuantPartOf(x,b,t)∧instanceOf(b,objectAggregate,t)→∃o(memberPartOf(o,b,t)∧(∃z(continuantPartOf(z,x,t)∧continuantPartOf(z,o,t)))))
#Proper continuant part of at all times (bfo:0000137), object aggregate (bfo:0000027), object (bfo:0000030) member part of at some time (bfo:0000129), continuant part of at some time (bfo:0000176)

ex:fsy-1
    a sh:NodeShape ;
    sh:targetObjectsOf bfo:0000137 ;
    sh:property [
        sh:path bfo:0000137 ;
        sh:in (bfo:0000027) ;
        sh:severity sh:Violation ;
        sh:message "ProperContinuant should be part of an ObjectAggregate"
    ] ;
    sh:property [
        sh:path (bfo:0000137 bfo:0000129) ;
        sh:in (bfo:0000030) ;
        sh:severity sh:Violation ;
        sh:message "All parts of an ObjectAggregate should overlap with at least one member"
    ] ;
    sh:property [
        sh:path ((bfo:0000137 bfo:0000176) bfo:0000129) ;
        sh:in (bfo:0000030) ;
        sh:severity sh:Violation ;
        sh:message "All proper continuant parts of an ObjectAggregate should overlap with at least one member"
    ] . 
```

```
#If a material entity has a proper part, then at least one of its proper parts is not an immaterial entity [adm-1]
#∀m,t(instanceOf(m,materialEntity,t)∧(∃mp(continuantPartOf(mp,m,t)∧mp̸=m))→∃mp(mp̸=m∧continuantPartOf(mp,m,t)∧¬instanceOf(mp,immaterialEntity,t)))
#Material entity (bfo:0000040), continuant part of at some time (bfo:0000176), immaterial entity (bfo:0000141)

ex:adm-1
    a sh:NodeShape ;
    sh:targetObjectsOf bfo:0000040 ;
    sh:property [
        sh:path (bfo:0000176) ;
        sh:maxCount 1 ;
        sh:severity sh:Violation ;
        sh:message "Material entity should have at most one proper part"
    ] ;
    sh:property [
        sh:path (bfo:0000176) ;
        sh:or ([
            sh:path (bfo:0000176) ;
            sh:not (sh:class bfo:0000141) ;
            sh:severity sh:Violation ;
            sh:message "Material entity should not have immaterial proper part"
        ]) ;
        sh:severity sh:Violation ;
        sh:message "Material entity should have at least one proper part that is not an immaterial entity"
    ] .  
```

```
#An object aggregate has member parts only disjoint objects [evk-1]
#∀b,c,t(memberPartOf(b,c,t)↔instanceOf(b,object,t)∧instanceOf(c,objectAggregate,t)∧properContinuantPartOf(b,c,t)∧(∀d(memberPartOf(d,c,t)→b=d∨¬(∃z(continuantPartOf(z,b,t)∧continuantPartOf(z,d,t))))))
#Member part of at all times (bfo:0000173), object (bfo:0000030), object aggregate (bfo:0000027), Proper continuant part of at all times (bfo:0000137), continuant part of at some time (bfo:0000176)

ex:evk-1
    a sh:NodeShape ;
    sh:targetObjectsOf bfo:0000173 ;
    sh:property [
        sh:path bfo:0000173 ;
        sh:in (bfo:0000030) ;
        sh:severity sh:Violation ;
        sh:message "Member part of an object aggregate should be an object"
    ] ;
    sh:property [
        sh:path (bfo:0000137 bfo:0000176) ;
        sh:in (bfo:0000027) ;
        sh:severity sh:Violation ;
        sh:message "Proper continuant part should be part of an object aggregate"
    ] ;
    sh:property [
        sh:path (bfo:0000173 bfo:0000176) ;
        sh:or ([
            sh:path (bfo:0000173 bfo:0000176) ;
            sh:equals sh:this ;
            sh:severity sh:Violation ;
            sh:message "Member part should not overlap with another member part"
        ]) ;
        sh:severity sh:Violation ;
        sh:message "Member part of an object aggregate should be disjoint from all other member parts"
    ] . 
```

Member part of and has member part are inverse relations [jrm-1]
∀t,a,b(memberPartOf(a,b,t)↔hasMemberPart(b,a,t))

Member part of is dissective on third argument, a temporal region [yip-1]
∀p,q,r,s(memberPartOf(p,q,r)∧temporalPartOf(s,r)→memberPartOf(p,q,s))

An object aggregate always has at least one member [uhs-1]
∀ag,t(instanceOf(ag,objectAggregate,t)→∃o1(instanceOf(o1,object,t)∧memberPartOf(o1,ag,t)))

Member part of is time indexed and has domain: object and range: object aggregate [dvq-1]
∀a,b,t(memberPartOf(a,b,t)→instanceOf(a,object,t)∧instanceOf(b,objectAggregate,t)∧instanceOf(t,temporalRegion,t))

A fiat object part =def a proper part of an object [yir-1]
∀f,t(instanceOf(f,fiatObjectPart,t)↔∃o(instanceOf(o,object,t)∧properContinuantPartOf(f,o,t)∧¬instanceOf(f,immaterialEntity,t)))

I is an immaterial entity = Def. i is an independent continuant that has no material entities as parts. [udu-1]
∀i,t(instanceOf(i,immaterialEntity,t)↔instanceOf(i,independentContinuant,t)∧¬(∃m(instanceOf(m,materialEntity,t)∧continuantPartOf(m,i,t))))

Any continuant that doesn’t s depend or g depend on something is an independant continuant [ilw-1]
∀c1(∃tinstanceOf(c1,independentContinuant,t)↔∃tinstanceOf(c1,continuant,t)∧¬(∃c2,t(specificallyDependsOn(c1,c2)∨genericallyDependsOn(c1,c2,t))))

An object aggregate has more than one member at at least one time [ibd-1]
∀ag(∃tinstanceOf(ag,objectAggregate,t)→∃o1,o2,t(o1̸=o2∧instanceOf(o1,object,t)∧memberPartOf(o1,ag,t)∧instanceOf(o2,object,t)∧memberPartOf(o2,ag,t)))

All parts of an aggregate overlap some member [fsy-1]
∀t,b,x(properContinuantPartOf(x,b,t)∧instanceOf(b,objectAggregate,t)→∃o(memberPartOf(o,b,t)∧(∃z(continuantPartOf(z,x,t)∧continuantPartOf(z,o,t)))))

If a material entity has a proper part, then at least one of its proper parts is not an immaterial entity [adm-1]
∀m,t(instanceOf(m,materialEntity,t)∧(∃mp(continuantPartOf(mp,m,t)∧mp̸=m))→∃mp(mp̸=m∧continuantPartOf(mp,m,t)∧¬instanceOf(mp,immaterialEntity,t)))

An object aggregate has member parts only disjoint objects [evk-1]
∀b,c,t(memberPartOf(b,c,t)↔instanceOf(b,object,t)∧instanceOf(c,objectAggregate,t)∧properContinuantPartOf(b,c,t)∧(∀d(memberPartOf(d,c,t)→b=d∨¬(∃z(continuantPartOf(z,b,t)∧continuantPartOf(z,d,t))))))

___

**BFO 2020 Occurrent Mereology Axioms**

Occurrent part of and has occurrent part are inverse relations [yvi-1]
∀a,b(occurrentPartOf(a,b)↔hasOccurrentPart(b,a))

Proper occurrent part of and has proper occurrent part are inverse relations [wim-1]
∀a,b(properOccurrentPartOf(a,b)↔hasProperOccurrentPart(b,a))

Occurrent part of is reflexive [hbj-1]
∀a(∃t instanceOf(a,occurrent,t)→occurrentPartOf(a,a))

Occurrent part of is antisymmetric [xlu-1]
∀a,b(occurrentPartOf(a,b)∧occurrentPartOf(b,a)→a=b)

A proper occurrent part of b means a is an occurrent part of b and a is not the same as b [okr-1]
∀x,y(properOccurrentPartOf(x,y)↔occurrentPartOf(x,y)∧x̸=y)

Occurrent part of is transitive [kad-1]
∀a,b,c(occurrentPartOf(a,b)∧occurrentPartOf(b,c)→occurrentPartOf(a,c))

If one occurrent is part of another, then the temporal region on which the former projects is a part of the temporal region on which the latter projects [ybr-1]
∀o1,o2(occurrentPartOf(o1,o2)→∀t(existsAt(o1,t)→existsAt(o2,t)))

Occurrent part of has domain occurrent and range occurrent [zmr-1]
∀a,b(occurrentPartOf(a,b)→∃tinstanceOf(a,occurrent,t)∧∃tinstanceOf(b,occurrent,t))

If a occurrent part of b then if a is an instance of process then b is an instance of process [csk-1]
∀p,q(occurrentPartOf(p,q)→(∃tinstanceOf(p,process,t)→∃tinstanceOf(q,process,t))

Proper temporal part of has domain occurrent and range occurrent [ees-1]
∀a,b(properTemporalPartOf(a,b)→∃tinstanceOf(a,occurrent,t)∧∃instanceOf(b,occurrent,t))

Proper occurrent part of has domain occurrent and range occurrent [yhc-1]
∀a,b(properOccurrentPartOf(a,b)→∃instanceOf(a,occurrent,t)∧∃instanceOf(b,occurrent,t))

Every process has a process boundary [aff-1]
∀p(∃tinstanceOf(p,process,t)→∃pb,t(instanceOf(pb,processBoundary,t)∧occurrentPartOf(pb,p)))

If a occurrent part of b then if a is an instance of temporal region then b is an instance of temporal region, and vice versa [gjl-1]
∀p,q(occurrentPartOf(p,q)→(∃t instanceOf(p,temporalRegion,t)↔∃t instanceOf(q,temporalRegion,t)))

If a has occurrent part b then if a is an instance of process boundary then b is an instance of process boundary [hdk-1]
∀p,q(hasOccurrentPart(p,q)→(∃tinstanceOf(p,processBoundary,t)→∃tinstanceOf(q,processBoundary,t)))

If a occurrent part of b then if a is an instance of spatiotemporal region then b is an instance of spatiotemporal region, and vice versa [myl-1]
∀p,q(occurrentPartOf(p,q)→(∃tinstanceOf(p,spatiotemporalRegion,t)↔∃t instanceOf(q,spatiotemporalRegion,t)))

Definition of temporal part for temporal regions [cmy-1]
∀b,c(∃tinstanceOf(b,temporalRegion,t)∧∃tinstanceOf(c,temporalRegion,t)→(temporalPartOf(b,c)↔occurrentPartOf(b,c)))

If a has occurrent part b then if a is an instance of process then b is an instance of process or process boundary [ccz-1]
∀p,q(hasOccurrentPart(p,q)→(∃tinstanceOf(p,process,t)→∃t(instanceOf(q,process,t)∨instanceOf(q,processBoundary,t))))

If a occurrent part of b then if a is an instance of process boundary then b is an instance of process or process boundary [ptm-1]
∀p,q(occurrentPartOf(p,q)→(∃tinstanceOf(p,processBoundary,t)→∃t(instanceOf(q,process,t)∨instanceOf(q,processBoundary,t))))

A process boundary is any temporal part of a process that has no proper temporal parts. [esh-1]
∀pb(∃tinstanceOf(pb,processBoundary,t)↔(∃p(temporalPartOf(pb,p)∧∃tinstanceOf(p,process,t)))∧(∃t(occupiesTemporalRegion(pb,t)∧instanceOf(t,temporalInstant,t))))

Occurrent part of has a unique product [hpc-1]
∀x,y(∃t(instanceOf(x,occurrent,t)∧instanceOf(y,occurrent,t)∧instanceOf(t,temporalRegion,t))→(∃w(occurrentPartOf(w,x)∧occurrentPartOf(w,y))→∃z(∀w(occurrentPartOf(w,z)↔occurrentPartOf(w,x)∧occurrentPartOf(w,y)))))

At least one process boundary needs to be at the first or last instant of the process it bounds [qsp-1]
∀p(∃tpinstanceOf(p,process,tp)→∃pb,tb,tp(occupiesTemporalRegion(p,tp)∧occurrentPartOf(pb,p)∧occupiesTemporalRegion(pb,tb)∧instanceOf(pb,processBoundary,tb)∧(∃ltp,ftp(hasFirstInstant(tp,ftp)∧hasLastInstant(tp,ltp)∧(tb=ftp∨tb=ltp)))))

B temporal part c (both spatiotemporal regions) iff b temporal projection is part of c’s temporal projection, and for all parts of b’s existence, if it spatially projects onto s at that time, then so does c [eom-1]
∀b,c(∃tinstanceOf(b,spatiotemporalRegion,t)∧∃tinstanceOf(c,spatiotemporalRegion,t)→(temporalPartOf(b,c)↔∃tb,tc(temporallyProjectsOnto(b,tb)∧temporallyProjectsOnto(c,tc)∧occurrentPartOf(tb,tc)∧(∀tp(occurrentPartOf(tp,tb)∧∃sspatiallyProjectsOnto(b,s,tp)→∃s(spatiallyProjectsOnto(b,s,tp)∧spatiallyProjectsOnto(c,s,tp)))))))

Two spatiotemporal regions are parts when they are temporal parts and their spatial projects are always parts [txf-1]
∀st1,st2(∃tinstanceOf(st1,spatiotemporalRegion,t)∧∃tinstanceOf(st2,spatiotemporalRegion,t)→(occurrentPartOf(st1,st2)↔(∃t1,t2(temporallyProjectsOnto(st1,t1)∧temporallyProjectsOnto(st2,t2)∧temporalPartOf(t1,t2)))∧(∀t(existsAt(st1,t)→∃s1,s2,tp(temporalPartOf(tp,t)∧spatiallyProjectsOnto(st1,s1,tp)∧spatiallyProjectsOnto(st2,s2,tp)∧continuantPartOf(s1,s2,tp))))))

___

**BFO 2020 Order Axioms**

Precedes and preceded by are inverse relations [tib-1]
∀a,b(precedes(a,b)↔precededBy(b,a))

Precedes is antisymmetric [hew-1]
∀a,b(precedes(a,b)→¬precedes(b,a))

Precedes is transitive [ctz-1]
∀a,b,c(precedes(a,b)∧precedes(b,c)→precedes(a,c))

If the last instant of a temporal region precedes the first instant of another, then the first region precedes the second [qqv-1]
∀i1,i2,l1,f2(hasLastInstant(i1,l1)∧hasFirstInstant(i2,f2)∧precedes(l1,f2)→precedes(i1,i2))

Precedes has domain occurrent and range occurrent [sen-1]
∀a,b(precedes(a,b)→∃tinstanceOf(a,occurrent,t)∧∃t instanceOf(b,occurrent,t))

If you are part of something that precedes something else, you also precede it [wix-1]
∀o1,o2,o1p,o2p(occurrentPartOf(o1p,o1)∧occurrentPartOf(o2p,o2)∧precedes(o1,o2)→precedes(o1p,o2p))

First instant of a temporal region that is not an instant precedes last instant [rzv-1]
∀t,ft,lt(¬instanceOf(t,temporalInstant,t)∧hasFirstInstant(t,ft)∧hasLastInstant(t,lt)
→precedes(ft,lt))

If one temporal region precedes another then the first last time point precedes the second first time point [miz-1]
∀t1,t2,l1,f2 (precedes(t1,t2)∧hasLastInstant(t1,l1)∧hasFirstInstant(t2,f2)∧l1̸=f2
→precedes(l1,f2))

If one occurrent precedes another then they do not overlap temporally [aou-1]
∀p,q(precedes(p,q)∨precedes(q,p)→¬(∃overlap(temporalPartOf(overlap,p)∧temporalPartOf(overlap,q))))

Temporal instants are totally ordered [qnf-1]
∀t1,t2(instanceOf(t1,temporalInstant,t1)∧instanceOf(t2,temporalInstant,t2)→precedes(t1,t2)∨precedes(t2,t1)∨t1=t2)

If the last instant of a temporal region is the first instant of another, the first region precedes the second [suk-1]
∀i1,i2,l1,f2(¬instanceOf(i1,temporalInstant,i1)∧¬instanceOf(i2,temporalInstant,i2)
∧hasLastInstant(i1,l1)∧hasFirstInstant(i2,f2)∧l1=f2→precedes(i1,i2))

A last instant is either part of an extended region or is preceded by it [acg-1]
∀l,i(instanceOf(l,temporalInstant,l)∧instanceOf(i,temporalRegion,i)∧¬instanceOf(i,temporalInstant,i)∧hasLastInstant(i,l)→(¬temporalPartOf(l,i)↔precedes(i,l)))

A first instant is either part of an extended region or precedes it [qga-1]
∀f,i(instanceOf(f,temporalInstant,f)∧instanceOf(i,temporalRegion,i)∧¬instanceOf(i,temporalInstant,i)∧hasFirstInstant(i,f)→(¬temporalPartOf(f,i) ↔precedes(f,i)))

If two temporal intervals do not overlap then one of them precedes the other [owb-1]
∀t1,t2(instanceOf(t1,temporalInterval,t1)∧instanceOf(t2,temporalInterval,t2)∧¬(∃part(temporalPartOf(part,t1)∧temporalPartOf(part,t2)))→precedes(t1,t2)∨precedes(t2,t1))

If you temporally occupy part of something that precedes something else, you also precede it [wff-1]
∀o1,o2(∃t1,t2((occupiesTemporalRegion(o1,t1)∨temporallyProjectsOnto(o1,t1)∨t1=o1)∧(occupiesTemporalRegion(o2,t2)∨temporallyProjectsOnto(o2,t2)∨t2=o2)∧precedes(t1,t2))↔precedes(o1,o2))

If two processes that occupy temporal intervals do not overlap, one of them precedes the other [duz-1]
∀o1,o2,t1,t2(occupiesTemporalRegion(o1,t1)∧occupiesTemporalRegion(o2,t2)
∧instanceOf(t1,temporalInterval,t1)∧instanceOf(t2,temporalInterval,t2)∧¬(∃part(temporalPartOf(part,t1)∧temporalPartOf(part,t2)))→precedes(o1,o2)∨precedes(o2,o1))

___

**BFO 2020 Participation Axioms**

Participates in and has participant are inverse relations [xjr-1]
∀t,a,b(participatesIn(a,b,t) ↔hasParticipant(b,a,t))

At every time a process exists it has a participant [trl-1]
∀p,t(instanceOf(p,process,t) →∃c participatesIn(c,p,t))

Participates in is dissective on third argument, a temporal region [yjm-1]
∀p,q,r,s(participatesIn(p,q,r)∧temporalPartOf(s,r) →participatesIn(p,q,s))

Participates in is time indexed and has domain: independent continuant but not spatial region or specifically dependent continuant or generically dependent continuant and range: process [ild-1]
∀a,b,t(participatesIn(a,b,t)→((instanceOf(a,independentContinuant,t)∧¬instanceOf(a,spatialRegion,t))∨instanceOf(a,specificallyDependentContinuant,t)∨instanceOf(a,genericallyDependentContinuant,t))∧instanceOf(b,process,t)∧instanceOf(t,temporalRegion,t))

At every time a specific dependent s participates in a process p there’s a part of that time, during which there’s an independent continuant that s s depends on, and that participates in p at that time [cgn-1]
∀sdc,p,t(instanceOf(sdc,specificallyDependentContinuant,t)∧participatesIn(sdc,p,t)→∃tp,ic(instanceOf(tp,temporalRegion,tp)∧temporalPartOf(tp,t)∧instanceOf(ic,independentContinuant,tp)∧¬instanceOf(ic,spatialRegion,tp)∧specificallyDependsOn(sdc,ic)∧participatesIn(ic,p,tp)))

If a generically dependent continuant participates in a process p then, if it is concretized as a process, that process is part of p, fand if concretized as an sdc then the bearer of that sdc participates in the process [fmm-1]
∀gdc,p,t(instanceOf(gdc,genericallyDependentContinuant,t)∧participatesIn(gdc,p,t)→∃tp,b(temporalPartOf(tp,t)∧concretizes(b,gdc,tp)∧((instanceOf(b,specificallyDependentContinuant,tp)∧(∃ic(specificallyDependsOn(b,ic)∧participatesIn(ic,p,tp))))∨(occurrentPartOf(b,p)∧existsAt(b,tp))))

___

**BFO 2020 Spatial Axioms**

Occurs in and environs are inverse relations [uys-1]
∀a,b(occursIn(a,b)↔environs(b,a))

Located in and location of are inverse relations [kaw-1]
∀t,a,b(locatedIn(a,b,t)↔locationOf(b,a,t))

Occurs in is dissective on first argument when it is an occurrent [jil-1]
∀p,q,r(occursIn(p,q)∧occurrentPartOf(r,p)→occursIn(r,q))

If a process (or process boundary) occurs in a continuant, that continuant exists at least as long as the process does [dxv-1]
∀p,c(occursIn(p,c)→∀t(existsAt(p,t)→existsAt(c,t)))

Located in is dissective on third argument, a temporal region [put-1]
∀p,q,r,s(locatedIn(p,q,r)∧temporalPartOf(s,r)→locatedIn(p,q,s))

Located in is a lower bound on second argument [evu-1]
∀p,q,r,s(locatedIn(p,q,r)∧continuantPartOf(q,s,r)→locatedIn(p,s,r))

Located in is dissective on first argument when it is a continuant [wty-1]
∀p,q,r,s(locatedIn(p,q,r)∧continuantPartOf(s,p,r)→locatedIn(s,q,r))

Occupies spatial region is functional on second argument [zls-1]
∀p,q,r,s(occupiesSpatialRegion(p,q,r)∧occupiesSpatialRegion(p,s,r) →q=s)

Occupies spatial region is dissective on third argument, a temporal region [mud-1]
∀p,q,r,s(occupiesSpatialRegion(p,q,r)∧temporalPartOf(s,r)→occupiesSpatialRegion(p,q,s))

Spatially projects onto is dissective on third argument, a temporal region [ivt-1]
∀p,q,r,s(spatiallyProjectsOnto(p,q,r)∧temporalPartOf(s,r)→spatiallyProjectsOnto(p,q,s))

Located in is transitive at a time [xlm-1]
∀a,b,c,t,t2(locatedIn(a,b,t)∧locatedIn(b,c,t2)∧temporalPartOf(t,t2)→locatedIn(a,c,t))

If a location of b then if a is an instance of continuant fiat boundary then b is an instance of continuant fiat boundary [wte-1]
∀p,q,t(locationOf(p,q,t)∧instanceOf(p,continuantFiatBoundary,t)→instanceOf(q,continuantFiatBoundary,t))

All spatial regions are part of a 3 dimensional spatial region [xcx-1]
∀s,t(instanceOf(s,spatialRegion,t)→∃s3(instanceOf(s3,threeDimensionalSpatialRegion,t)∧continuantPartOf(s,s3,t)))

Occurs in is lower bound location [czc-1]
∀p,c1,c2(occursIn(p,c1)∧(∀t(existsAt(p,t)↔existsAt(c2,t)∧continuantPartOf(c1,c2,t)))→occursIn(p,c2))

If something is located in something else then the region of the first is part of the region of the second [uas-1]
∀a,b,t(locatedIn(a,b,t)→∃r1,r2,t2(temporalPartOf(t2,t)∧occupiesSpatialRegion(a,r1,t2)∧occupiesSpatialRegion(b,r2,t2)∧continuantPartOf(r1,r2,t2)))

Occurs in has domain process or process boundary and range material entity or site [tfw-1]
∀a,b(occursIn(a,b)→(∃t(instanceOf(a,process,t)∨instanceOf(a,processBoundary,t)))∧(∃t(instanceOf(b,materialEntity,t)∨instanceOf(b,site,t))))

Spatial regions don’t change what they are part of. [mlb-1]
∀s,sp (∃t(instanceOf(s,spatialRegion,t)∧continuantPartOf(sp,s,t))→∀t(∃sPrime continuantPartOf(sPrime,s,t) →continuantPartOf(sp,s,t)))

Occupies spatial region is time indexed and has domain: independent continuant but not spatial region and range: spatial region [lzw-1]
∀a,b,t(occupiesSpatialRegion(a,b,t)→instanceOf(a,independentContinuant,t)∧¬instanceOf(a,spatialRegion,t)∧instanceOf(b,spatialRegion,t)∧instanceOf(t,temporalRegion,t))

If there are two independent continuants that are not spatial regions, and one is part of the other, then it is located in the other [bao-1]
∀a,b,t(continuantPartOf(a,b,t)∧instanceOf(a,independentContinuant,t)∧¬instanceOf(a,spatialRegion,t)∧instanceOf(b,independentContinuant,t)∧¬instanceOf(b,spatialRegion,t)→locatedIn(a,b,t))

Spatial region is the union of zero dimensional spatial region, one dimensional spatial region, two dimensional spatial region, and three dimensional spatial region [wnm-1]
∀i,t(instanceOf(i,spatialRegion,t)→instanceOf(i,zeroDimensionalSpatialRegion,t)∨instanceOf(i,oneDimensionalSpatialRegion,t)∨instanceOf(i,twoDimensionalSpatialRegion,t)∨instanceOf(i,threeDimensionalSpatialRegion,t))

No two material entities occupy the same space unless they coincide [scr-1]
∀m1,m2,s,t(instanceOf(m1,materialEntity,t)∧occupiesSpatialRegion(m1,s,t)∧instanceOf(m2,materialEntity,t)∧occupiesSpatialRegion(m2,s,t)→(continuantPartOf(m2,m1,t)∧continuantPartOf(m1,m2,t))∨m1=m2)

Located in is time indexed and has domain: independent continuant but not spatial region and range: independent continuant but not spatial region [bge-1]
∀a,b,t(locatedIn(a,b,t)→instanceOf(a,independentContinuant,t)∧¬instanceOf(a,spatialRegion,t)∧instanceOf(b,independentContinuant,t)∧¬instanceOf(b,spatialRegion,t)∧instanceOf(t,temporalRegion,t))

At all times t, there’s a part of t when c occupies spatial region r iff every part of c occupies a part of r, and there isn’t a smaller part of r that c occupies. [grv-1]
∀c,r,t(instanceOf(c,independentContinuant,t)∧¬instanceOf(c,spatialRegion,t)∧instanceOf(r,spatialRegion,t)→∃t2(temporalPartOf(t2,t)∧(occupiesSpatialRegion(c,r,t2)↔(∀cp(continuantPartOf(cp,c,t2)→∀rp(occupiesSpatialRegion(cp,rp,t2)→continuantPartOf(rp,r,t2))))∧¬(∃r′(r′̸=r∧continuantPartOf(r′,r,t2)∧occupiesSpatialRegion(c,r′,t2))))))

___

**BFO 2020 Spatiotemporal Axioms**

If something occupies a temporal region, then it exists at that region [bmc-1]
∀a,t(occupiesTemporalRegion(a,t) →existsAt(a,t))

Exists at is a lower bound on first argument [jqz-1]
∀p,q,r(existsAt(p,q)∧temporalPartOf(p,r) →existsAt(r,q))

Occupies temporal region is functional on second argument [wzd-1]
∀p,q,r(occupiesTemporalRegion(p,q)∧occupiesTemporalRegion(p,r) →q=r)

Temporally projects onto is functional on second argument [jtq-1]
∀p,q,r(temporallyProjectsOnto(p,q)∧temporallyProjectsOnto(p,r) →q=r)

Spatially projects onto is functional on second argument [fdb-1]
∀p,q,r,s(spatiallyProjectsOnto(p,q,r)∧spatiallyProjectsOnto(p,s,r) →q=s)

Occupies spatiotemporal region is functional on second argument [uqt-1]
∀p,q,r(occupiesSpatiotemporalRegion(p,q)∧occupiesSpatiotemporalRegion(p,r) →q=r)

Occurs in is a lower bound on second argument [yex-1]
∀p,c1,c2(occursIn(p,c1)∧(∀t(existsAt(p,t) ↔locatedIn(c1,c2,t))) →occursIn(p,c2))

If a occupies spatial region b then if a is an instance of site then b is an instance of three dimensional spatial region [uqb-1]
∀p,q,t (occupiesSpatialRegion(p,q,t)∧instanceOf(p,site,t)
→instanceOf(q,threeDimensionalSpatialRegion,t))

The temporal region during which a process occurs is the same as that which the spatiotemporal region the process occupies temporally projects onto [cur-1]
∀p,t(occupiesTemporalRegion(p,t)↔∃st(occupiesSpatiotemporalRegion(p,st)∧temporallyProjectsOnto(st,t)))

A process boundary occupies a spatiotemporal instant [atz-1]
∀pb,tr(∃tinstanceOf(pb,processBoundary,t)∧occupiesTemporalRegion(pb,tr)→instanceOf(tr,temporalInstant,tr))

For every process there’s a corresponding spatiotemporal region [qyy-1]
∀p(∃t(instanceOf(p,process,t)∨instanceOf(p,processBoundary,t))→∃s occupiesSpatiotemporalRegion(p,s))

Temporally projects onto has domain spatiotemporal region and range temporal region [cvr-1]
∀a,b (temporallyProjectsOnto(a,b)→∃t instanceOf(a,spatiotemporalRegion,t)∧∃t instanceOf(b,temporalRegion,t))

Spatiotemporal regions always project on to some temporal region [scq-1]
∀st(∃tinstanceOf(st,spatiotemporalRegion,t)→∃t(instanceOf(t,temporalRegion,t)∧temporallyProjectsOnto(st,t)))

Spatially projects onto is time indexed and has domain: spatiotemporal region and range: spatial region [blj-1]
∀a,b,t(spatiallyProjectsOnto(a,b,t)→instanceOf(a,spatiotemporalRegion,t)∧instanceOf(b,spatialRegion,t)∧instanceOf(t,temporalRegion,t))

Every temporal region is a projection from a spatiotemporal region [xco-1]
∀tr(∃tinstanceOf(tr,temporalRegion,t)→∃st(∃tinstanceOf(st,spatiotemporalRegion,t)∧temporallyProjectsOnto(st,tr)))

Spatiotemporal regions always project on to some spatial region at any time [geq-1]
∀st,t(instanceOf(st,spatiotemporalRegion,t)→∃s,tp(temporalPartOf(tp,t)∧instanceOf(s,spatialRegion,tp)∧spatiallyProjectsOnto(st,s,tp)))


Occupies temporal region has domain process or process boundary and range temporal region [lyx-1]
∀a,b(occupiesTemporalRegion(a,b)→(∃t(instanceOf(a,process,t)∨instanceOf(a,processBoundary,t)))∧∃t instanceOf(b,temporalRegion,t))

Every spatial region is a projection from a spatiotemporal region [mdb-1]
∀sr (∃t instanceOf(sr,spatialRegion,t)→∃st(∃t instanceOf(st,spatiotemporalRegion,t)∧∃t spatiallyProjectsOnto(st,sr,t)))

Occupies spatiotemporal region has domain process or process boundary and range spatiotemporal region [vvo-1]
∀a,b(occupiesSpatiotemporalRegion(a,b)→(∃t(instanceOf(a,process,t)∨instanceOf(a,processBoundary,t)))∧∃t instanceOf(b,spatiotemporalRegion,t))

A process occupies at least a temporal interval [fzy-1]
∀proc,tr(∃tinstanceOf(proc,process,t)∧occupiesTemporalRegion(proc,tr)→∃interval(instanceOf(interval,temporalInterval,interval)∧temporalPartOf(interval,tr)))

If one occurrent is part of another, then the temporal region of the first is part of the temporal region of the second [jiv-1]
∀o1,o2,t1,t2((∃t(instanceOf(o1,process,t)∨instanceOf(o1,processBoundary,t)))∧∃t instanceOf(o2,process,t)∧occurrentPartOf(o1,o2)∧occupiesTemporalRegion(o1,t1)∧occupiesTemporalRegion(o2,t2)→temporalPartOf(t1,t2))

If one process or process boundary is part of another, then their corresponding temporal regions are also in a parthood relation [iqe-1]
∀o1,o2,st1,st2((∃t(instanceOf(o1,process,t)∨instanceOf(o1,processBoundary,t)))∧(∃t(instanceOf(o2,process,t)∨instanceOf(o2,processBoundary,t)))∧occurrentPartOf(o1,o2)∧occupiesSpatiotemporalRegion(o1,st1)∧occupiesSpatiotemporalRegion(o2,st2)→occurrentPartOf(st1,st2))

If a process or process boundary is part of another, their spatiotemporal regions are part too [kqv-1]
∀p1,p2((∃tinstanceOf(p1,process,t)∨∃tinstanceOf(p1,processBoundary,t))∧(∃tinstanceOf(p2,process,t)∨∃tinstanceOf(p2,processBoundary,t))→(occurrentPartOf(p1,p2)↔∃st1,st2(occupiesSpatiotemporalRegion(p1,st1)∧occupiesSpatiotemporalRegion(p2,st2)∧occurrentPartOf(st1,st2))))

Process or process boundary p occupies temporal region t iff every part of p temporally occupies a part of t, and there isn’t asmaller part of t that p occupies. [tao-1]
∀o,t((∃t1instanceOf(o,process,t1)∨∃t1instanceOf(o,processBoundary,t1))∧instanceOf(t,temporalRegion,t)→(occupiesTemporalRegion(o,t)↔(∀op(occurrentPartOf(op,o)→∀tp(occupiesTemporalRegion(op,tp)→occurrentPartOf(tp,t))))∧¬(∃t′(t′̸=t∧occurrentPartOf(t′,t)∧occupiesTemporalRegion(o,t′)))))

Process p (or boundary) occupies spatiotemporal region st iff every part of p occupies spatiotemporal region a part of st, and there isn’t a smaller part of st that p occupies. [dki-1]
∀o,st((∃t1instanceOf(o,process,t1)∨∃t1instanceOf(o,processBoundary,t1))∧∃t1instanceOf(st,spatiotemporalRegion,t1)→(occupiesSpatiotemporalRegion(o,st)↔(∀op(occurrentPartOf(op,o)→∀stp(occupiesSpatiotemporalRegion(op,stp)→occurrentPartOf(stp,st))))∧¬(∃st′(st′̸=st∧occurrentPartOf(st′,st)∧occupiesSpatiotemporalRegion(o,st′)))))

___

**BFO 2020 Specific Dependency Axioms**

Inheres in and bearer of are inverse relations [dzz-1]
∀a,b(inheresIn(a,b) ↔bearerOf(b,a))

Realizes and has realization are inverse relations [pvk-1]
∀a,b(realizes(a,b) ↔hasRealization(b,a))

Has material basis and material basis of are inverse relations [tla-1]
∀t,a,b(hasMaterialBasis(a,b,t) ↔materialBasisOf(b,a,t))

Specifically depends on and specifically depended on by are inverse relations [yct-1]
∀a,b(specificallyDependsOn(a,b) ↔specificallyDependedOnBy(b,a))

When a role is realized the bearer of the role participates in the realization process [grx-1]
∀r,p,b(realizes(p,r)∧inheresIn(r,b) →∃t participatesIn(b,p,t))

Has material basis is dissective on third argument, a temporal region [hnl-1]
∀p,q,r,s(hasMaterialBasis(p,q,r)∧temporalPartOf(s,r) →hasMaterialBasis(p,q,s))

Realizes has domain process and range realizable entity [oot-1]
∀a,b(realizes(a,b) →∃t instanceOf(a,process,t)∧∃t instanceOf(b,realizableEntity,t))

Specifically depends on is transitive [myu-1]
∀a,b,c(specificallyDependsOn(a,b)∧specificallyDependsOn(b,c)∧a̸=c→specificallyDependsOn(a,c))

If s s depends on c then s and c never share common parts (s,c continuants) [nfe-1]
∀s,c(specificallyDependsOn(s,c)→¬(∃w,t(continuantPartOf(w,s,t)∧continuantPartOf(w,c,t))))

A realizable entity exists at least at the beginning of the realization process [vhg-1]
∀r,p(realizes(p,r)→∃proct,first(occupiesTemporalRegion(p,proct)∧hasFirstInstant(proct,first)∧existsAt(r,first)))

Has material basis is time indexed and has domain: disposition and range: material entity [cfs-1]
∀a,b,t(hasMaterialBasis(a,b,t)→instanceOf(a,disposition,t)∧instanceOf(b,materialEntity,t)∧instanceOf(t,temporalRegion,t))

If x s depends on y then there’s at least one time when they both exist [iyu-1]
∀s,c(specificallyDependsOn(s,c)→(∃t(existsAt(s,t)∧existsAt(c,t)))∧(∀t(existsAt(s,t) →existsAt(c,t))))

DEFINITION: b is a relational quality = Def. b is a quality and there exists distinct c and d such that at all times t, b inheres in c if and only b specifically depends on. [dbp-1]
∀b(∃tinstanceOf(b,relationalQuality,t)↔(∃c,d(c̸=d∧inheresIn(b,c)∧specificallyDependsOn(b,d)))∧∃t instanceOf(b,quality,t))

Inheres in has domain specifically dependent continuant and range independent continuant but not spatial region [lmq-1]
∀a,b(inheresIn(a,b)→∃tinstanceOf(a,specificallyDependentContinuant,t)∧(∃t(instanceOf(b,independentContinuant,t)∧¬instanceOf(b,spatialRegion,t))))

A inheres in b =Def. a is a specifically dependent continuant and b is an independent continuant that is not a spatial region and a s depends on b. [tht-1]
∀a,b(inheresIn(a,b)↔specificallyDependsOn(a,b)∧(∃t(instanceOf(a,specificallyDependentContinuant,t)∧instanceOf(b,independentContinuant,t)∧¬instanceOf(b,spatialRegion,t))))

Definition of specifically dependent continuant. [akq-1]
∀s(∃tinstanceOf(s,specificallyDependentContinuant,t)↔∃c,t(instanceOf(s,continuant,t)∧instanceOf(c,independentContinuant,t)∧¬instanceOf(c,spatialRegion,t)∧specificallyDependsOn(s,c)))

The material basis of a disposition is part of the bearer of the disposition [uxo-1]
∀m,d,b (∃t instanceOf(m,materialEntity,t)∧∃t instanceOf(d,disposition,t)∧∃t instanceOf(b,materialEntity,t)∧inheresIn(d,b)→∀t(hasMaterialBasis(d,m,t)→continuantPartOf(m,b,t)))

Specifically depends on has domain specifically dependent continuant and range specifically dependent continuant or independent continuant but not spatial region [kkl-1]
∀a,b(specificallyDependsOn(a,b)→∃tinstanceOf(a,specificallyDependentContinuant,t)∧(∃t(instanceOf(b,specificallyDependentContinuant,t)∨(instanceOf(b,independentContinuant,t)∧¬instanceOf(b,spatialRegion,t)))))

At every time a specific dependent s participates in a process p there’s a part of that time, during which there’s an independent continuant that s s depends on, and that participates in p at that time [cgn-1]
∀sdc,p,t(instanceOf(sdc,specificallyDependentContinuant,t)∧participatesIn(sdc,p,t)→∃tp,ic(instanceOf(tp,temporalRegion,tp)∧temporalPartOf(tp,t)∧instanceOf(ic,independentContinuant,tp)∧¬instanceOf(ic,spatialRegion,tp)∧specificallyDependsOn(sdc,ic)∧participatesIn(ic,p,tp)))

__

**BFO 2020 At T Temporalized Axioms**

Located in at some time [asd-1]
∀p,q(locatedInAtSomeTime(p,q) ↔∃t(existsAt(p,t)∧existsAt(q,t)∧locatedIn(p,q,t)))

Concretizes at some time [gkc-1]
∀p,q (concretizesAtSomeTime(p,q)
↔∃t(existsAt(p,t)∧existsAt(q,t)∧concretizes(p,q,t)))

Location of at some time [spm-1]
∀p,q(locationOfAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧locationOf(p,q,t)))

Is carrier of at some time [qkm-1]
∀p,q (isCarrierOfAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧isCarrierOf(p,q,t)))

Member part of at some time [kax-1]
∀p,q(memberPartOfAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧memberPartOf(p,q,t)))

Has member part at some time [smy-1]
∀p,q(hasMemberPartAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧hasMemberPart(p,q,t)))

Has participant at some time [ebs-1]
∀p,q(hasParticipantAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧hasParticipant(p,q,t)))

Participates in at some time [oia-1]
∀p,q(participatesInAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧participatesIn(p,q,t)))

Rdf:type is interpreted as meaning an instance is a given type whenever it exists, and that the instance exists at some point. [fyy-1]
∀c,i(rdfType(c,i) ↔(∀t(existsAt(i,t) →instanceOf(i,c,t)))∧∃t existsAt(i,t))

Is concretized by at some time [zgk-1]
∀p,q(isConcretizedByAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧isConcretizedBy(p,q,t)))

Material basis of at some time [exa-1]
∀p,q(materialBasisOfAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧materialBasisOf(p,q,t)))

Continuant part of at some time [lzq-1]
∀p,q(continuantPartOfAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧continuantPartOf(p,q,t)))

Has material basis at some time [fqc-1]
∀p,q(hasMaterialBasisAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧hasMaterialBasis(p,q,t)))

Has continuant part at some time [jvz-1]
∀p,q(hasContinuantPartAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧hasContinuantPart(p,q,t)))

Generically depends on at some time [vrq-1]
∀p,q(genericallyDependsOnAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧genericallyDependsOn(p,q,t)))

Occupies spatial region at some time [yci-1]
∀p,q(occupiesSpatialRegionAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧occupiesSpatialRegion(p,q,t)))

Spatially projects onto at some time [epa-1]
∀p,q(spatiallyProjectsOntoAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧spatiallyProjectsOnto(p,q,t)))

Proper continuant part of at some time [sql-1]
∀p,q(properContinuantPartOfAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧properContinuantPartOf(p,q,t)))

Has proper continuant part at some time [ule-1]
∀p,q(hasProperContinuantPartAtSomeTime(p,q)↔∃t(existsAt(p,t)∧existsAt(q,t)∧hasProperContinuantPart(p,q,t)))

Located in at all times [vdo-1]
∀p,q(locatedInAtAllTimes(p,q)↔(∃t(locatedIn(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t)→locatedIn(p,q,t))))

Concretizes at all times [uge-1]
∀p,q(concretizesAtAllTimes(p,q)↔(∃t(concretizes(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t)→concretizes(p,q,t))))

Location of at all times [imi-1]
∀p,q(locationOfAtAllTimes(p,q)↔(∃t(locationOf(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t)→locationOf(p,q,t))))

Is carrier of at all times [fya-1]
∀p,q(isCarrierOfAtAllTimes(p,q)↔(∃t(isCarrierOf(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t)→isCarrierOf(p,q,t))))

Member part of at all times [maf-1]
∀p,q(memberPartOfAtAllTimes(p,q)↔(∃t(memberPartOf(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →memberPartOf(p,q,t))))

Has member part at all times [xwi-1]
∀p,q(hasMemberPartAtAllTimes(p,q)↔(∃t(hasMemberPart(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →hasMemberPart(p,q,t))))

Has participant at all times [wyo-1]
∀p,q(hasParticipantAtAllTimes(p,q)↔(∃t(hasParticipant(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →hasParticipant(p,q,t))))

Participates in at all times [ghl-1]
∀p,q(participatesInAtAllTimes(p,q)↔(∃t(participatesIn(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t)→participatesIn(p,q,t))))

Is concretized by at all times [qhq-1]
∀p,q(isConcretizedByAtAllTimes(p,q)↔(∃t(isConcretizedBy(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →isConcretizedBy(p,q,t))))

Material basis of at all times [scx-1]
∀p,q(materialBasisOfAtAllTimes(p,q)↔(∃t(materialBasisOf(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t)→materialBasisOf(p,q,t))))

Continuant part of at all times [ztt-1]
∀p,q(continuantPartOfAtAllTimes(p,q)↔(∃t(continuantPartOf(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →continuantPartOf(p,q,t))))

Has material basis at all times [qdl-1]
∀p,q(hasMaterialBasisAtAllTimes(p,q)↔(∃t(hasMaterialBasis(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →hasMaterialBasis(p,q,t))))

Has continuant part at all times [uhy-1]
∀p,q(hasContinuantPartAtAllTimes(p,q)↔(∃t(hasContinuantPart(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →hasContinuantPart(p,q,t))))

Generically depends on at all times [wie-1]
∀p,q(genericallyDependsOnAtAllTimes(p,q)↔(∃t(genericallyDependsOn(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →genericallyDependsOn(p,q,t))))

Occupies spatial region at all times [tpr-1]
∀p,q(occupiesSpatialRegionAtAllTimes(p,q)↔(∃t(occupiesSpatialRegion(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →occupiesSpatialRegion(p,q,t))))

Spatially projects onto at all times [ogh-1]
∀p,q(spatiallyProjectsOntoAtAllTimes(p,q)↔(∃t(spatiallyProjectsOnto(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →spatiallyProjectsOnto(p,q,t))))

Proper continuant part of at all times [jiz-1]
∀p,q(properContinuantPartOfAtAllTimes(p,q)↔(∃t(properContinuantPartOf(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →properContinuantPartOf(p,q,t))))

Has proper continuant part at all times [mxe-1]
∀p,q(hasProperContinuantPartAtAllTimes(p,q)↔(∃t(hasProperContinuantPart(p,q,t)∧existsAt(p,t)))∧(∀t(existsAt(p,t) →hasProperContinuantPart(p,q,t))))

___

**BFO 2020 Temporal Region Axioms**

Has last instant and last instant of are inverse relations [wal-1]
∀a,b(hasLastInstant(a,b)↔lastInstantOf(b,a))

Has first instant and first instant of are inverse relations [bon-1]
∀a,b(hasFirstInstant(a,b)↔firstInstantOf(b,a))

Temporal part of and has temporal part are inverse relations [boo-1]
∀a,b(temporalPartOf(a,b)↔hasTemporalPart(b,a))

Temporal part of for occurrents implies occurrent part of [bal-1]
∀a,b(temporalPartOf(a,b)→occurrentPartOf(a,b))

Proper temporal part of and has proper temporal part are inverse relations [dbc-1]
∀a,b(properTemporalPartOf(a,b)↔hasProperTemporalPart(b,a))

If something is an instance of temporal region at t, then t is part of that temporal region [njq-1]
∀ti,t(instanceOf(ti,temporalRegion,t)→temporalPartOf(t,ti))

Temporal part of is reflexive [bvr-1]
∀a(∃t instanceOf(a,occurrent,t)→temporalPartOf(a,a))

Temporal part of is antisymmetric [zdq-1]
∀a,b(temporalPartOf(a,b)∧temporalPartOf(b,a) →a=b)

Proper temporal part of is asymmetric [aqu-1]
∀a,b(properTemporalPartOf(a,b)→¬properTemporalPartOf(b,a))

Has last instant is functional on second argument [ogd-1]
∀p,q,r(hasLastInstant(p,q)∧hasLastInstant(p,r)→q=r)

Temporal part of is reflexive [dbj-1]
∀a(∃t instanceOf(a,temporalRegion,t)→temporalPartOf(a,a))

Has first instant is functional on second argument [fwf-1]
∀p,q,r(hasFirstInstant(p,q)∧hasFirstInstant(p,r)→q=r)

A proper temporal part of b means a is a temporal part of b and b a is not the same as b [aeu-1]
∀x,y(properTemporalPartOf(x,y) ↔temporalPartOf(x,y)∧x̸=y)

Instance of is dissective on third argument, a temporal region [qaf-1]
∀p,q,r,s(instanceOf(p,q,r)∧temporalPartOf(s,r) →instanceOf(p,q,s))

Temporal part of is transitive [bfq-1]
∀a,b,c(temporalPartOf(a,b)∧temporalPartOf(b,c) →temporalPartOf(a,c))

The first and last time points for an instant are the instant itself [nfo-1]
∀i(instanceOf(i,temporalInstant,i) ↔hasFirstInstant(i,i)∧hasLastInstant(i,i))

The only part of a temporal instant is itself [pir-1]
∀p,q(∃t instanceOf(p,temporalInstant,t)∧hasTemporalPart(p,q) →p=q)

Temporal regions are instances at themselves [tvx-1]
∀a,u(∃t(instanceOf(a,temporalRegion,t)∧instanceOf(a,u,t)) →instanceOf(a,u,a))

Proper temporal part of is transitive [mns-1]
∀a,b,c(properTemporalPartOf(a,b)∧properTemporalPartOf(b,c)→properTemporalPartOf(a,c))

If the last instant of a temporal region precedes the first instant of another, then the first region precedes the second [qqv-1]
∀i1,i2,l1,f2 (hasLastInstant(i1,l1)∧hasFirstInstant(i2,f2)∧precedes(l1,f2)→precedes(i1,i2))

Any temporal region has a first and last instant [daf-1]
∀i (instanceOf(i,temporalRegion,i)→∃t1,t2(hasFirstInstant(i,t1)∧hasLastInstant(i,t2)))

All temporal regions are part of a temporal interval [mvd-1]
∀t(instanceOf(t,temporalRegion,t)→∃i(instanceOf(i,temporalInterval,i)∧temporalPartOf(t,i)))

Temporal part of has domain occurrent and range occurrent [ruj-1]
∀a,b(temporalPartOf(a,b) →∃t instanceOf(a,occurrent,t)∧∃t instanceOf(b,occurrent,t))

First instant of a temporal region that is not an instant precedes last instant [rzv-1]
∀t,ft,lt(¬instanceOf(t,temporalInstant,t)∧hasFirstInstant(t,ft)∧hasLastInstant(t,lt)→precedes(ft,lt))

If one temporal region precedes another then the first last time point precedes the second first time point [miz-1]
∀t1,t2,l1,f2(precedes(t1,t2)∧hasLastInstant(t1,l1)∧hasFirstInstant(t2,f2)∧l1̸=f2→precedes(l1,f2))

If a temporal part of b then if a is an instance of temporal region then b is an instance of temporal region, and vice versa[mjn-1]
∀p,q (temporalPartOf(p,q)→(∃t instanceOf(p,temporalRegion,t) ↔∃tinstanceOf(q,temporalRegion,t)))

Has last instant has domain temporal region and range temporal instant [jtk-1]
∀a,b(hasLastInstant(a,b)→∃tinstanceOf(a,temporalRegion,t)∧∃tinstanceOf(b,temporalInstant,t))

Has first instant has domain temporal region and range temporal instant [fwk-1]
∀a,b(hasFirstInstant(a,b)→∃tinstanceOf(a,temporalRegion,t)∧∃tinstanceOf(b,temporalInstant,t))

A one dimensional temporal region has at least one interval as part [jhe-1]
∀t(instanceOf(t,oneDimensionalTemporalRegion,t)→∃p(temporalPartOf(p,t)∧instanceOf(p,temporalInterval,p)))

Temporal instants are totally ordered [qnf-1]
∀t1,t2(instanceOf(t1,temporalInstant,t1)∧instanceOf(t2,temporalInstant,t2)→precedes(t1,t2)∨precedes(t2,t1)∨t1=t2)

Temporal region is the union of zero dimensional temporal region and one dimensional temporal region [hgs-1]
∀i,t(instanceOf(i,temporalRegion,t)→instanceOf(i,zeroDimensionalTemporalRegion,t)∨instanceOf(i,oneDimensionalTemporalRegion,t))

If a temporal part of b then if a is an instance of one dimensional temporal region then b is an instance of one dimensionaltemporal region [mei-1]
∀p,q(temporalPartOf(p,q)→(∃tinstanceOf(p,oneDimensionalTemporalRegion,t)→∃t instanceOf(q,oneDimensionalTemporalRegion,t)))

If a has temporal part b then if a is an instance of zero dimensional temporal region then b is an instance of zero dimensional temporal region [bnt-1]
∀p,q(hasTemporalPart(p,q)→(∃tinstanceOf(p,zeroDimensionalTemporalRegion,t)→∃t instanceOf(q,zeroDimensionalTemporalRegion,t)))

If the last instant of a temporal region is the first instant of another, the first region precedes the second [suk-1]
∀i1,i2,l1,f2(¬instanceOf(i1,temporalInstant,i1)∧¬instanceOf(i2,temporalInstant,i2)∧hasLastInstant(i1,l1)∧hasFirstInstant(i2,f2)∧l1=f2→precedes(i1,i2))

A last instant is either part of an extended region or is preceded by it [acg-1]
∀l,i(instanceOf(l,temporalInstant,l)∧instanceOf(i,temporalRegion,i)∧¬instanceOf(i,temporalInstant,i)∧hasLastInstant(i,l)→(¬temporalPartOf(l,i) ↔precedes(i,l)))

A first instant is either part of an extended region or precedes it [qga-1]
∀f,i(instanceOf(f,temporalInstant,f)∧instanceOf(i,temporalRegion,i)∧¬instanceOf(i,temporalInstant,i)∧hasFirstInstant(i,f)→(¬temporalPartOf(f,i) ↔precedes(f,i)))

If two temporal intervals do not overlap then one of them precedes the other [owb-1]
∀t1,t2(instanceOf(t1,temporalInterval,t1)∧instanceOf(t2,temporalInterval,t2)∧¬(∃part(temporalPartOf(part,t1)∧temporalPartOf(part,t2)))→precedes(t1,t2)∨precedes(t2,t1))

If a has temporal part b then if a is an instance of one dimensional temporal region then b is an instance of one dimensional temporal region or zero dimensional temporal region [eeg-1]
∀p,q(hasTemporalPart(p,q)→(∃tinstanceOf(p,oneDimensionalTemporalRegion,t)→∃t(instanceOf(q,oneDimensionalTemporalRegion,t)∨instanceOf(q,zeroDimensionalTemporalRegion,t))))

The first temporal instant is such that it precedes every part of the interval that doesn’t have the first instant as part [ixz-1]
∀fi,i(instanceOf(fi,temporalInstant,fi)∧instanceOf(i,temporalRegion,i)∧¬instanceOf(i,temporalInstant,i)→(hasFirstInstant(i,fi)→∀ip(temporalPartOf(ip,i)∧¬temporalPartOf(fi,ip)→precedes(fi,ip))))

The last temporal instant is such that every part of the interval that doesn’t have the last instant as part precedes it [nhd-1]
∀li,i(instanceOf(li,temporalInstant,li)∧instanceOf(i,temporalRegion,i)∧¬instanceOf(i,temporalInstant,i)→(hasLastInstant(i,li)→(∀ip(temporalPartOf(ip,i)∧¬temporalPartOf(li,ip)→precedes(ip,li)))))

Intervals have no internal gaps [ekm-1]
∀i,start,end(instanceOf(i,temporalInterval,i)∧hasFirstInstant(i,start)∧hasLastInstant(i,end)→¬(∃gap,gapStart,gapEnd(hasFirstInstant(gap,gapStart)∧hasLastInstant(gap,gapEnd)∧precedes(gapEnd,end)∧precedes(start,gapStart)∧¬temporalPartOf(gap,i))))

Temporal part of has weak supplementation [vbw-1]
∀x,y(instanceOf(x,temporalRegion,x)∧instanceOf(y,temporalRegion,y)→(properTemporalPartOf(x,y)→∃z(properTemporalPartOf(z,y)∧¬(∃overlap(instanceOf(overlap,temporalRegion,overlap)∧temporalPartOf(overlap,x)∧temporalPartOf(overlap,z))))))

Any temporal instant that precedes the last instant of an interval and which is preceded by the first instant is part of theinterval [zlp-1]
∀t,r(instanceOf(t,temporalInstant,t)∧instanceOf(r,temporalInterval,r)→hasFirstInstant(r,t)∨hasLastInstant(r,t)∨(∃f,l(instanceOf(r,temporalInterval,r)∧hasFirstInstant(r,f)∧hasLastInstant(r,l)∧precedes(t,l)∧precedes(f,t))↔properTemporalPartOf(t,r)))

Two intervals are identical if their first and last instants are the same and if an instant is part of one of the intervals it is also part of the other [xkl-1]
∀i1,i2(instanceOf(i1,temporalInterval,i1)∧instanceOf(i2,temporalInterval,i2)→(∃f,l(hasFirstInstant(i1,f)∧hasFirstInstant(i2,f)∧hasLastInstant(i1,l)∧hasLastInstant(i2,l)∧(temporalPartOf(l,i1)↔temporalPartOf(l,i2))∧(temporalPartOf(f,i1)↔temporalPartOf(f,i2)))→i1=i2))

Temporal part of has unique product [wsg-1]
∀x,y(instanceOf(x,temporalRegion,x)∧instanceOf(y,temporalRegion,y)→(∃o(temporalPartOf(o,x)∧temporalPartOf(o,y))→∃z(instanceOf(z,temporalRegion,z)∧(∀w(instanceOf(w,temporalRegion,w)∧instanceOf(z,temporalRegion,z)→(temporalPartOf(w,z)↔temporalPartOf(w,x)∧temporalPartOf(w,y)))))))

An interval has no gaps [nui-1]
∀i,start,end(instanceOf(i,temporalInterval,i)∧hasFirstInstant(i,start)∧hasLastInstant(i,end)→¬(∃gap,gapStart,gapEnd(¬instanceOf(gap,temporalInstant,gap)∧hasFirstInstant(gap,gapStart)∧hasLastInstant(gap,gapEnd)∧(precedes(gapEnd,end)∨(temporalPartOf(end,i)∧gapEnd=end))∧(precedes(start,gapStart)∨(temporalPartOf(start,i)∧gapStart=start))
∧¬temporalPartOf(gap,i))))

Intervals have no gaps strong version every two instants without another in between bound an interval [cop-1]
∀i,start,end (instanceOf(i,temporalInterval,i)∧hasFirstInstant(i,start)∧hasLastInstant(i,end)→∀t1,t2(temporalPartOf(t1,i)∧temporalPartOf(t2,i)∧instanceOf(t1,temporalInstant,t1)∧instanceOf(t2,temporalInstant,t2)∧precedes(t1,t2)∧¬(∃t3(instanceOf(t3,temporalInstant,t3)∧precedes(t1,t3)∧precedes(t3,t2)))→∃fill(instanceOf(fill,temporalInterval,fill)∧hasFirstInstant(fill,t1)∧hasLastInstant(fill,t2)∧temporalPartOf(fill,i))))

___

**BFO 2020 Universal Declaration Axioms**

Role is a universal [ewm-1]
universal(role)

Site is a universal [yhb-1]
universal(site)

Object is a universal [kxo-1]
universal(object)

History is a universal [gki-1]
universal(history)

Process is a universal [bsm-1]
universal(process)

Quality is a universal [mit-1]
universal(quality)

Function is a universal [rym-1]
universal(function)

Fiat line is a universal [spk-1]
universal(fiatLine)

Occurrent is a universal [lkt-1]
universal(occurrent)

Continuant is a universal [axs-1]
universal(continuant)

Fiat point is a universal [rns-1]
universal(fiatPoint)

Disposition is a universal [mld-1]
universal(disposition)

Fiat surface is a universal [ebw-1]
universal(fiatSurface)

Spatial region is a universal [qga-1]
universal(spatialRegion)

Material entity is a universal [hru-1]
universal(materialEntity)

Temporal region is a universal [toj-1]
universal(temporalRegion)

Fiat object part is a universal [csp-1]
universal(fiatObjectPart)

Object aggregate is a universal [cqv-1]
universal(objectAggregate)

Process boundary is a universal [zqv-1]
universal(processBoundary)

Temporal instant is a universal [bjs-1]
universal(temporalInstant)

Immaterial entity is a universal [zcc-1]
universal(immaterialEntity)

Realizable entity is a universal [gpp-1]
universal(realizableEntity)

Temporal interval is a universal [kuz-1]
universal(temporalInterval)

Relational quality is a universal [zrp-1]
universal(relationalQuality)

Spatiotemporal region is a universal [mdh-1]
universal(spatiotemporalRegion)

Independent continuant is a universal [ufw-1]
universal(independentContinuant)

Continuant fiat boundary is a universal [zvi-1]
universal(continuantFiatBoundary)

One dimensional spatial region is a universal [zwl-1]
universal(oneDimensionalSpatialRegion)

Two dimensional spatial region is a universal [whi-1]
universal(twoDimensionalSpatialRegion)

One dimensional temporal region is a universal [qar-1]
universal(oneDimensionalTemporalRegion)

Zero dimensional spatial region is a universal [vij-1]
universal(zeroDimensionalSpatialRegion)

Universals and particulars comprise the whole domain of discourse [eto-1]
∀x(universal(x)∨particular(x))

Generically dependent continuant is a universal [qiz-1]
universal(genericallyDependentContinuant)

Three dimensional spatial region is a universal [qov-1]
universal(threeDimensionalSpatialRegion)

Zero dimensional temporal region is a universal [bau-1]
universal(zeroDimensionalTemporalRegion)

Specifically dependent continuant is a universal [wda-1]
universal(specificallyDependentContinuant)

Universals are not particulars [qkp-1]
¬(∃x(universal(x)∧particular(x)))

History is subclass of process [abo-1]
∀t,x(instanceOf(x,history,t)→instanceOf(x,process,t))

Process is subclass of occurrent [lso-1]
∀t,x(instanceOf(x,process,t)→instanceOf(x,occurrent,t))

Function is subclass of disposition [lnj-1]
∀t,x(instanceOf(x,function,t)→instanceOf(x,disposition,t))

Object is subclass of material entity [vbm-1]
∀t,x(instanceOf(x,object,t)→instanceOf(x,materialEntity,t))

Role is subclass of realizable entity [tcp-1]
∀t,x(instanceOf(x,role,t)→instanceOf(x,realizableEntity,t))

Site is subclass of immaterial entity [tcd-1]
∀t,x(instanceOf(x,site,t)→instanceOf(x,immaterialEntity,t))

If something is an instance of temporal region at t, then t is part of that temporal region [njq-1]
∀ti,t(instanceOf(ti,temporalRegion,t)→temporalPartOf(t,ti))

Temporal region is subclass of occurrent [ejl-1]
∀t,x(instanceOf(x,temporalRegion,t)→instanceOf(x,occurrent,t))

Disposition, role are mutually disjoint [bwk-1]
¬(∃x,t(instanceOf(x,disposition,t)∧instanceOf(x,role,t)))

Process boundary is subclass of occurrent [xot-1]
∀t,x(instanceOf(x,processBoundary,t)→instanceOf(x,occurrent,t))

Relational quality is subclass of quality [taj-1]
∀t,x(instanceOf(x,relationalQuality,t)→instanceOf(x,quality,t))

Disposition is subclass of realizable entity [fxd-1]
∀t,x(instanceOf(x,disposition,t)→instanceOf(x,realizableEntity,t))

Continuant, occurrent are mutually disjoint [wrf-1]
¬(∃x,t(instanceOf(x,continuant,t)∧instanceOf(x,occurrent,t)))

Spatiotemporal region is subclass of occurrent [les-1]
∀t,x(instanceOf(x,spatiotemporalRegion,t)→instanceOf(x,occurrent,t))

Fiat object part is subclass of material entity [lal-1]
∀t,x(instanceOf(x,fiatObjectPart,t)→instanceOf(x,materialEntity,t))

Object aggregate is subclass of material entity [fda-1]
∀t,x(instanceOf(x,objectAggregate,t)→instanceOf(x,materialEntity,t))

Spatial region is subclass of immaterial entity [bre-1]
∀t,x(instanceOf(x,spatialRegion,t)→instanceOf(x,immaterialEntity,t))

Independent continuant is subclass of continuant [wyq-1]
∀t,x(instanceOf(x,independentContinuant,t)→instanceOf(x,continuant,t))

Fiat line is subclass of continuant fiat boundary [dhy-1]
∀t,x(instanceOf(x,fiatLine,t)→instanceOf(x,continuantFiatBoundary,t))

Quality, realizable entity are mutually disjoint [ksk-1]
¬(∃x,t(instanceOf(x,quality,t)∧instanceOf(x,realizableEntity,t)))

Fiat point is subclass of continuant fiat boundary [xlm-1]
∀t,x(instanceOf(x,fiatPoint,t)→instanceOf(x,continuantFiatBoundary,t))

Fiat surface is subclass of continuant fiat boundary [kfj-1]
∀t,x(instanceOf(x,fiatSurface,t)→instanceOf(x,continuantFiatBoundary,t))

Material entity is subclass of independent continuant [faf-1]
∀t,x(instanceOf(x,materialEntity,t)→instanceOf(x,independentContinuant,t))

Immaterial entity is subclass of independent continuant [bzp-1]
∀t,x(instanceOf(x,immaterialEntity,t)→instanceOf(x,independentContinuant,t))

Quality is subclass of specifically dependent continuant [nbm-1]
∀t,x(instanceOf(x,quality,t)→instanceOf(x,specificallyDependentContinuant,t))

Continuant fiat boundary is subclass of immaterial entity [tgs-1]
∀t,x(instanceOf(x,continuantFiatBoundary,t)→instanceOf(x,immaterialEntity,t))

Material entity, immaterial entity are mutually disjoint [sij-1]
¬(∃x,t(instanceOf(x,materialEntity,t)∧instanceOf(x,immaterialEntity,t)))

Generically dependent continuant is subclass of continuant [zyw-1]
∀t,x(instanceOf(x,genericallyDependentContinuant,t)→instanceOf(x,continuant,t)) 

Specifically dependent continuant is subclass of continuant [dhv-1]
∀t,x(instanceOf(x,specificallyDependentContinuant,t)→instanceOf(x,continuant,t))

One dimensional spatial region is subclass of spatial region [fzn-1]
∀t,x(instanceOf(x,oneDimensionalSpatialRegion,t)→instanceOf(x,spatialRegion,t))

Two dimensional spatial region is subclass of spatial region [abo-1]
∀t,x(instanceOf(x,twoDimensionalSpatialRegion,t)→instanceOf(x,spatialRegion,t))

Zero dimensional spatial region is subclass of spatial region [abh-1]
∀t,x(instanceOf(x,zeroDimensionalSpatialRegion,t)→instanceOf(x,spatialRegion,t))

One dimensional temporal region is subclass of temporal region [fpd-1]
∀t,x(instanceOf(x,oneDimensionalTemporalRegion,t)→instanceOf(x,temporalRegion,t))

Three dimensional spatial region is subclass of spatial region [apt-1]
∀t,x(instanceOf(x,threeDimensionalSpatialRegion,t)→instanceOf(x,spatialRegion,t))

Zero dimensional temporal region is subclass of temporal region [pvu-1]
∀t,x(instanceOf(x,zeroDimensionalTemporalRegion,t)→instanceOf(x,temporalRegion,t))

Temporal instant is subclass of zero dimensional temporal region [bjp-1]
∀t,x(instanceOf(x,temporalInstant,t)→instanceOf(x,zeroDimensionalTemporalRegion,t))

Temporal interval is subclass of one dimensional temporal region [fye-1]
∀t,x(instanceOf(x,temporalInterval,t)→instanceOf(x,oneDimensionalTemporalRegion,t))

Entity is either universal or particular, so not all are instantiated. Instead make a predicate ’entity’ analogous to particular universal [vgn-1]
∀x(∃t(instanceOf(x,continuant,t)∨instanceOf(x,occurrent,t))→entity(x))

Realizable entity is subclass of specifically dependent continuant [qix-1]
∀t,x(instanceOf(x,realizableEntity,t)→instanceOf(x,specificallyDependentContinuant,t))

If something is a role at any time then as long as it exists it is a role. [hxo-1]
∀x(∃tinstanceOf(x,role,t)→∀t(existsAt(x,t)→instanceOf(x,role,t)))

If something is a site at any time then as long as it exists it is a site. [txn-1]
∀x(∃tinstanceOf(x,site,t)→∀t(existsAt(x,t)→instanceOf(x,site,t)))

If something is a quality at any time then as long as it exists it is a quality. [jdo-1]
∀x(∃tinstanceOf(x,quality,t)→∀t(existsAt(x,t)→instanceOf(x,quality,t)))

If something is a function at any time then as long as it exists it is a function. [hww-1]
∀x(∃tinstanceOf(x,function,t)→∀t(existsAt(x,t)→instanceOf(x,function,t)))

One dimensional temporal region, zero dimensional temporal region are mutually disjoint [zkj-1]
¬(∃x,t(instanceOf(x,oneDimensionalTemporalRegion,t)∧instanceOf(x,zeroDimensionalTemporalRegion,t)))

If something is a fiat line at any time then as long as it exists it is a fiat line. [ylr-1]
∀x(∃tinstanceOf(x,fiatLine,t)→∀t(existsAt(x,t)→instanceOf(x,fiatLine,t)))

If something is a continuant at any time then as long as it exists it is a continuant. [ghs-1]
∀x(∃tinstanceOf(x,continuant,t)→∀t(existsAt(x,t)→instanceOf(x,continuant,t)))

If something is a fiat point at any time then as long as it exists it is a fiat point. [cqf-1]
∀x(∃tinstanceOf(x,fiatPoint,t)→∀t(existsAt(x,t)→instanceOf(x,fiatPoint,t)))

If something is a disposition at any time then as long as it exists it is a disposition. [ijx-1]
∀x(∃tinstanceOf(x,disposition,t)→∀t(existsAt(x,t)→instanceOf(x,disposition,t)))

If something is a fiat surface at any time then as long as it exists it is a fiat surface. [dyv-1]
∀x(∃tinstanceOf(x,fiatSurface,t)→∀t(existsAt(x,t)→instanceOf(x,fiatSurface,t)))

If something is a spatial region at any time then as long as it exists it is a spatial region. [thk-1]
∀x(∃tinstanceOf(x,spatialRegion,t)→∀t(existsAt(x,t)→instanceOf(x,spatialRegion,t)))

If something is a material entity at any time then as long as it exists it is a material entity. [opd-1]
∀x(∃tinstanceOf(x,materialEntity,t)→∀t(existsAt(x,t)→instanceOf(x,materialEntity,t)))

If something is a immaterial entity at any time then as long as it exists it is a immaterial entity. [nlc-1]
∀x(∃tinstanceOf(x,immaterialEntity,t)→∀t(existsAt(x,t)→instanceOf(x,immaterialEntity,t)))

If something is a realizable entity at any time then as long as it exists it is a realizable entity. [gsg-1]
∀x(∃tinstanceOf(x,realizableEntity,t)→∀t(existsAt(x,t)→instanceOf(x,realizableEntity,t)))

If something is a relational quality at any time then as long as it exists it is a relational quality. [jyh-1]
∀x(∃tinstanceOf(x,relationalQuality,t)→∀t(existsAt(x,t)→instanceOf(x,relationalQuality,t)))

If something is a independent continuant at any time then as long as it exists it is a independent continuant. [otk-1]
∀x(∃tinstanceOf(x,independentContinuant,t)→∀t(existsAt(x,t)→instanceOf(x,independentContinuant,t)))

If something is a continuant fiat boundary at any time then as long as it exists it is a continuant fiat boundary. [yuh-1]
∀x(∃tinstanceOf(x,continuantFiatBoundary,t)→∀t(existsAt(x,t)→instanceOf(x,continuantFiatBoundary,t)))

If something is a one dimensional spatial region at any time then as long as it exists it is a one dimensional spatial region. [bld-1]
∀x(∃tinstanceOf(x,oneDimensionalSpatialRegion,t)→∀t(existsAt(x,t)→instanceOf(x,oneDimensionalSpatialRegion,t)))

If something is a two dimensional spatial region at any time then as long as it exists it is a two dimensional spatial region. [uld-1]
∀x(∃tinstanceOf(x,twoDimensionalSpatialRegion,t)→∀t(existsAt(x,t)→instanceOf(x,twoDimensionalSpatialRegion,t)))

If something is a zero dimensional spatial region at any time then as long as it exists it is a zero dimensional spatial region. [vsa-1]
∀x(∃tinstanceOf(x,zeroDimensionalSpatialRegion,t)→∀t(existsAt(x,t)→instanceOf(x,zeroDimensionalSpatialRegion,t)))

If something is a generically dependent continuant at any time then as long as it exists it is a generically dependent continuant. [iup-1]
∀x(∃tinstanceOf(x,genericallyDependentContinuant,t)→∀t(existsAt(x,t)→instanceOf(x,genericallyDependentContinuant,t)))

If something is a three dimensional spatial region at any time then as long as it exists it is a three dimensional spatial region. [qpr-1]
∀x(∃tinstanceOf(x,threeDimensionalSpatialRegion,t)→∀t(existsAt(x,t)→instanceOf(x,threeDimensionalSpatialRegion,t)))

If something is a specifically dependent continuant at any time then as long as it exists it is a specifically dependent continuant. [hke-1]
∀x(∃tinstanceOf(x,specificallyDependentContinuant,t)→∀t(existsAt(x,t)→instanceOf(x,specificallyDependentContinuant,t)))

No occurrent changes type during its existence [ayr-1]
∀o(∃tinstanceOf(o,occurrent,t)→∀u(∃tinstanceOf(o,u,t)→∀t(instanceOf(o,occurrent,t)↔instanceOf(o,u,t))))

Fiat surface, fiat line, fiat point are mutually disjoint [sjf-1]
¬(∃x,t(instanceOf(x,fiatSurface,t)∧instanceOf(x,fiatLine,t)))
∧¬(∃x,t(instanceOf(x,fiatSurface,t)∧instanceOf(x,fiatPoint,t)))
∧¬(∃x,t(instanceOf(x,fiatLine,t)∧instanceOf(x,fiatPoint,t)))

Site, spatial region, continuant fiat boundary are mutually disjoint [twc-1]
¬(∃x,t(instanceOf(x,site,t)∧instanceOf(x,spatialRegion,t)))
∧¬(∃x,t(instanceOf(x,site,t)∧instanceOf(x,continuantFiatBoundary,t)))
∧¬(∃x,t(instanceOf(x,spatialRegion,t)∧instanceOf(x,continuantFiatBoundary,t)))

Specifically dependent continuant, independent continuant, generically dependent continuant are mutually disjoint [cig-1]
¬(∃x,t(instanceOf(x,specificallyDependentContinuant,t)
∧instanceOf(x,independentContinuant,t)))
∧¬(∃x,t(instanceOf(x,specificallyDependentContinuant,t)
∧instanceOf(x,genericallyDependentContinuant,t)))
∧¬(∃x,t(instanceOf(x,independentContinuant,t)
∧instanceOf(x,genericallyDependentContinuant,t)))

Process, spatiotemporal region, process boundary, temporal region are mutually disjoint [mem-1]
¬(∃x,t(instanceOf(x,process,t)∧instanceOf(x,spatiotemporalRegion,t)))
∧¬(∃x,t(instanceOf(x,process,t)∧instanceOf(x,processBoundary,t)))
∧¬(∃x,t(instanceOf(x,process,t)∧instanceOf(x,temporalRegion,t)))
∧¬(∃x,t(instanceOf(x,spatiotemporalRegion,t)∧instanceOf(x,processBoundary,t)))
∧¬(∃x,t(instanceOf(x,spatiotemporalRegion,t)∧instanceOf(x,temporalRegion,t)))
∧¬(∃x,t(instanceOf(x,processBoundary,t)∧instanceOf(x,temporalRegion,t)))

Continuant, material entity, object, fiat object part, object aggregate, site, immaterial entity, continuant fiat boundary, fiat surface, fiat line, fiat point, spatial region, three-dimensional spatial region, two dimensional spatial region, one dimensional spatial region, zero dimensional spatial region, independent continuant, generically dependent continuant, specifically dependent continuant, quality, relational quality, function, disposition, realizable entity, role, occurrent, process, process boundary, temporal region, zero dimensional temporal region, temporal instant, one dimensional temporal region, temporal interval, history, spatiotemporal region are all different [xtf-1]

The axiom is too large to show. It is a conjunction of 1190 pairwise inequalities between the constants continuant, materialEntity, object, fiatObjectPart, objectAggregate, site, immaterialEntity, continuantFiatBoundary, fiatSurface, fiatLine, fiatPoint, spatialRegion, threeDimensionalSpatialRegion, twoDimensionalSpatialRegion, oneDimensionalSpatialRegion, zeroDimensionalSpatialRegion, independentContinuant, genericallyDependentContinuant, specificallyDependentContinuant, quality,
relationalQuality, function, disposition, realizableEntity, role, occurrent, process, processBoundary, temporalRegion, zeroDimensionalTemporalRegion, temporalInstant, oneDimensionalTemporalRegion, temporalInterval, history and spatiotemporalRegion.

Zero dimensional spatial region, one dimensional spatial region, two dimensional spatial region, three dimensional spatial region are mutually disjoint [luc-1]

¬(∃x,t(instanceOf(x,zeroDimensionalSpatialRegion,t)
∧instanceOf(x,oneDimensionalSpatialRegion,t)))
∧¬(∃x,t(instanceOf(x,zeroDimensionalSpatialRegion,t)
∧instanceOf(x,twoDimensionalSpatialRegion,t)))
∧¬(∃x,t(instanceOf(x,zeroDimensionalSpatialRegion,t)
∧instanceOf(x,threeDimensionalSpatialRegion,t)))
∧¬(∃x,t(instanceOf(x,oneDimensionalSpatialRegion,t)
∧instanceOf(x,twoDimensionalSpatialRegion,t)))
∧¬(∃x,t(instanceOf(x,oneDimensionalSpatialRegion,t)
∧instanceOf(x,threeDimensionalSpatialRegion,t)))
∧¬(∃x,t(instanceOf(x,twoDimensionalSpatialRegion,t)
∧instanceOf(x,threeDimensionalSpatialRegion,t)))

___

**Part 2–Objective 2:**

3. Validate the SHACL schema/file for BFO by running the SHACL file against the knowledge graph based on BFO and generate a report absent errors or warnings

