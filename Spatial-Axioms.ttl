# BFO 2020 Spatial Axioms

@prefix bfo: <http://purl.obolibrary.org/obo/BFO_> .

# Occurs in and environs are inverse relations [uys-1]
# ∀a,b(occursIn(a,b)↔environs(b,a))

# OWL:
# bfo:0000066 owl:inverseOf bfo:0000183

# SHACL v1:
# bfo:uys-1-1
#    a sh:PropertyShape ;
#    sh:path bfo:0000066 ;
#    sh:inversePath bfo:0000183 ;
#    sh:severity sh:Violation ;
#    sh:message "Environs is inverse of Occurs In" .

# bfo:uys-1-2
#    a sh:PropertyShape ;
#    sh:path bfo:0000183 ;
#    sh:inversePath bfo:0000066 ;
#    sh:severity sh:Violation ;
#    sh:message "Occurs In is inverse of Environs" .


# SHACL v2:

bfo:uys-1-1 a sh:NodeShape ;
       sh:resultSeverity sh:Violation ;
       sh:message "Occurs in and environs are inverse relations" ;
       rdfs:comment "∀a,b(occursIn(a,b)↔environs(b,a))"
       sh:targetSubjectsOf bfo:0000066 ;
       sh:or ( [ sh:not        [ sh:property [ sh:path bfo:0000066 ] ] ]
               [ sh:property   [ sh:path [ sh:inversePath bfo:0000183 ] ;
                                 sh:minCount 1 ] ] ) .

bfo:uys-1-2 a sh:NodeShape ;
       sh:resultSeverity sh:Violation ;
       sh:message "Occurs in and environs are inverse relations" ;
       rdfs:comment "∀a,b(occursIn(a,b)↔environs(b,a))"
       sh:targetSubjectsOf bfo:0000183 ;
       sh:or ( [ sh:not        [ sh:property [ sh:path bfo:0000183 ] ] ]
               [ sh:property   [ sh:path [ sh:inversePath bfo:0000066 ] ;
                                 sh:minCount 1 ] ] ) .

# Located in and location of are inverse relations [kaw-1]
# ∀t,a,b(locatedIn(a,b,t)↔locationOf(b,a,t))

bfo:kaw-1-1 a sh:NodeShape ;
      sh:resultSeverity sh:Violation ;
      sh:message "Located in and location of are inverse relations" ;
      rdfs:comment "∀t,a,b(locatedIn(a,b,t)↔locationOf(b,a,t))"
      sh:targetSubjectsOf bfo:0000171 ; # located IN at some time
      sh:or ( [ sh:not        [ sh:property [ sh:path bfo:0000171 ] ] ]
              [ sh:property   [ sh:path [ sh:inversePath bfo:0000124 ] ;
                                sh:minCount 1 ] ] ) .


bfo:kaw-1-2 a sh:NodeShape ;
      sh:resultSeverity sh:Violation ;
      sh:message "Located in and location of are inverse relations" ;
      rdfs:comment "∀t,a,b(locatedIn(a,b,t)↔locationOf(b,a,t))"
      sh:targetSubjectsOf bfo:0000124 ; # location OF at some time
      sh:or ( [ sh:not        [ sh:property [ sh:path bfo:0000124 ] ] ]
              [ sh:property   [ sh:path [ sh:inversePath bfo:0000171 ] ;
                                sh:minCount 1 ] ] ) .

# Occurs in is dissective on first argument when it is an occurrent [jil-1]
# ∀p,q,r(occursIn(p,q)∧occurrentPartOf(r,p)→occursIn(r,q))

# This references the PropertyShape for “occurs in” in the BFO SHACL schema generated by Astrea (probably should change the IRI)
# This adds more conditions to that same PropertyShape
# Copied from Ali but I wasn’t able to test this

<https://astrea.linkeddata.es/shapes#e9da0c515cbbe401a7597413916018c5>
   sh:message   "Violation of the dissectivity axiom: {ex:occursIn}({0}, {1}) and {ex:occurrentPartOf}({2}, {0}), but not {ex:occursIn}({2}, {1})." ;
   sh:condition [
       rdf:type sh:SPARQLConstraint ;
       sh:message "SPARQL query for checking dissectivity" ;
       sh:select """ ASK {
                 ?p bfo:0000066 ?q .
                 ?r bfo:0000132 ?p .
                 FILTER NOT EXISTS {
                       ?r bfo:0000066 ?q .
                   }
               } """ ;
    ] .


# If a process (or process boundary) occurs in a continuant, that continuant exists at least as long as the process does [dxv-1]
# ∀p,c(occursIn(p,c)→∀t(existsAt(p,t)→existsAt(c,t)))


# Located in is dissective on third argument, a temporal region [put-1]
# ∀p,q,r,s(locatedIn(p,q,r)∧temporalPartOf(s,r)→locatedIn(p,q,s))
# Step 1. First convert to ∀p,q,r,s(¬(locatedIn(p,q,r)∧temporalPartOf(s,r)) ∨ locatedIn(p,q,s)) ...

bfo:put-1 a sh:NodeShape ;
      sh:resultSeverity sh:Violation ;
      sh:message "Located in is dissective on third argument, a temporal region" ;
      rdfs:comment "∀p,q,r,s(locatedIn(p,q,r)∧temporalPartOf(s,r)→locatedIn(p,q,s))" ;
      rdfs:comment "If Raleigh is located in NC at 1990, and 1990 is part of 20th century, then Raleigh is located in NC at 20th century" ;
      sh:targetSubjectsOf bfo:0000171 ; # located in at some time
      sh:or ( [ sh:not [ sh:and ( [ sh:property [ sh:path bfo:0000171 ] ]
                                  [ sh:property [ sh:path bfo:0000139 ] ] ) ] ]
              [ sh:property [ sh:path bfo:0000171 ] ] ) .

# Located in is a lower bound on second argument [evu-1]
# ∀p,q,r,s(locatedIn(p,q,r)∧continuantPartOf(q,s,r)→locatedIn(p,s,r))

# Located in is dissective on first argument when it is a continuant [wty-1]
# ∀p,q,r,s(locatedIn(p,q,r)∧continuantPartOf(s,p,r)→locatedIn(s,q,r))

# Occupies spatial region is functional on second argument [zls-1]
# ∀p,q,r,s(occupiesSpatialRegion(p,q,r)∧occupiesSpatialRegion(p,s,r) →q=s)

# Occupies spatial region is dissective on third argument, a temporal region [mud-1]
# ∀p,q,r,s(occupiesSpatialRegion(p,q,r)∧temporalPartOf(s,r)→occupiesSpatialRegion(p,q,s))

# Spatially projects onto is dissective on third argument, a temporal region [ivt-1]
# ∀p,q,r,s(spatiallyProjectsOnto(p,q,r)∧temporalPartOf(s,r)→spatiallyProjectsOnto(p,q,s))

# Located in is transitive at a time [xlm-1]
# ∀a,b,c,t,t2(locatedIn(a,b,t)∧locatedIn(b,c,t2)∧temporalPartOf(t,t2)→locatedIn(a,c,t))

# If a location of b then if a is an instance of continuant fiat boundary then b is an instance of continuant fiat boundary [wte-1]
# ∀p,q,t(locationOf(p,q,t)∧instanceOf(p,continuantFiatBoundary,t)→instanceOf(q,continuantFiatBoundary,t))

# All spatial regions are part of a 3 dimensional spatial region [xcx-1]
# ∀s,t(instanceOf(s,spatialRegion,t)→∃s3(instanceOf(s3,threeDimensionalSpatialRegion,t)∧continuantPartOf(s,s3,t)))

# Occurs in is lower bound location [czc-1]
# ∀p,c1,c2(occursIn(p,c1)∧(∀t(existsAt(p,t)↔existsAt(c2,t)∧continuantPartOf(c1,c2,t)))→occursIn(p,c2))

# If something is located in something else then the region of the first is part of the region of the second [uas-1]
# ∀a,b,t(locatedIn(a,b,t)→∃r1,r2,t2(temporalPartOf(t2,t)∧occupiesSpatialRegion(a,r1,t2)∧occupiesSpatialRegion(b,r2,t2)∧continuantPartOf(r1,r2,t2)))

# Occurs in has domain process or process boundary and range material entity or site [tfw-1]
# ∀a,b(occursIn(a,b)→(∃t(instanceOf(a,process,t)∨instanceOf(a,processBoundary,t)))∧(∃t(instanceOf(b,materialEntity,t)∨instanceOf(b,site,t))))

# Spatial regions don’t change what they are part of. [mlb-1]
# ∀s,sp (∃t(instanceOf(s,spatialRegion,t)∧continuantPartOf(sp,s,t))→∀t(∃sPrime continuantPartOf(sPrime,s,t) →continuantPartOf(sp,s,t)))

# Occupies spatial region is time indexed and has domain: independent continuant but not spatial region and range: spatial region [lzw-1]
# ∀a,b,t(occupiesSpatialRegion(a,b,t)→instanceOf(a,independentContinuant,t)∧¬instanceOf(a,spatialRegion,t)∧instanceOf(b,spatialRegion,t)∧instanceOf(t,temporalRegion,t))

# If there are two independent continuants that are not spatial regions, and one is part of the other, then it is located in the other [bao-1]
# ∀a,b,t(continuantPartOf(a,b,t)∧instanceOf(a,independentContinuant,t)∧¬instanceOf(a,spatialRegion,t)∧instanceOf(b,independentContinuant,t)∧¬instanceOf(b,spatialRegion,t)→locatedIn(a,b,t))

# Spatial region is the union of zero dimensional spatial region, one dimensional spatial region, two dimensional spatial region, and three dimensional spatial region [wnm-1]
# ∀i,t(instanceOf(i,spatialRegion,t)→instanceOf(i,zeroDimensionalSpatialRegion,t)∨instanceOf(i,oneDimensionalSpatialRegion,t)∨instanceOf(i,twoDimensionalSpatialRegion,t)∨instanceOf(i,threeDimensionalSpatialRegion,t))

# No two material entities occupy the same space unless they coincide [scr-1]
# ∀m1,m2,s,t(instanceOf(m1,materialEntity,t)∧occupiesSpatialRegion(m1,s,t)∧instanceOf(m2,materialEntity,t)∧occupiesSpatialRegion(m2,s,t)→(continuantPartOf(m2,m1,t)∧continuantPartOf(m1,m2,t))∨m1=m2)

# Located in is time indexed and has domain: independent continuant but not spatial region and range: independent continuant but not spatial region [bge-1]
# ∀a,b,t(locatedIn(a,b,t)→instanceOf(a,independentContinuant,t)∧¬instanceOf(a,spatialRegion,t)∧instanceOf(b,independentContinuant,t)∧¬instanceOf(b,spatialRegion,t)∧instanceOf(t,temporalRegion,t))

# At all times t, there’s a part of t when c occupies spatial region r iff every part of c occupies a part of r, and there isn’t a smaller part of r that c occupies. [grv-1]
# ∀c,r,t(instanceOf(c,independentContinuant,t)∧¬instanceOf(c,spatialRegion,t)∧instanceOf(r,spatialRegion,t)→∃t2(temporalPartOf(t2,t)∧(occupiesSpatialRegion(c,r,t2)↔(∀cp(continuantPartOf(cp,c,t2)→∀rp(occupiesSpatialRegion(cp,rp,t2)→continuantPartOf(rp,r,t2))))∧¬(∃r′(r′̸=r∧continuantPartOf(r′,r,t2)∧occupiesSpatialRegion(c,r′,t2))))))
